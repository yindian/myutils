--- imv.c.bak	Tue May 17 23:19:14 2011
+++ imv.c	Wed Jan 18 02:05:29 2012
@@ -343,8 +343,8 @@
 
 static unsigned char alpha_background[2][3] =
 {
-   { 200,40,200 },
-   { 150,30,150 },
+   { 255,255,255 },
+   { 255,255,255 },
 };
 
 // given raw decoded data from stbi_load, make it into a proper Image (e.g. creating a
@@ -353,6 +353,43 @@
 float lmin=0,lmax=1;
 int mono;
 #endif
+
+int autorotate = 0; // 0: don't rotate; 1: landscape (w:h>1.3); 2: portrait
+void check_rotate(int *pimage_x, int *pimage_y, uint8 **pimage_data)
+{
+    int i,j,k,l;
+    int image_x = *pimage_x;
+    int image_y = *pimage_y;
+    uint8 *image_data = *pimage_data;
+    if (autorotate &&
+        (autorotate == 1 && image_y * 3 >= image_x * 4) ||
+        (autorotate == 2 && image_x * 3 >= image_y * 4)) {
+        uint8 *rotated_data = (uint8 *) malloc(image_x * image_y * BPP);
+        if (rotated_data) {
+            k = 0;
+            for (j=0; j < image_y; ++j) {
+                l = ((image_x-1)*image_y + j) * BPP;
+                for (i=0; i < image_x; ++i) {
+#if BPP != 4
+                    rotated_data[l+0] = image_data[k+0];
+                    rotated_data[l+1] = image_data[k+1];
+                    rotated_data[l+2] = image_data[k+2];
+					//rotated_data[l+3] = image_data[k+3];
+#else
+                    *(uint32 *)(rotated_data+l) = *(uint32 *)(image_data+k);
+#endif
+                    k += BPP;
+                    l -= image_y * BPP;
+                }
+            }
+            free(image_data);
+            *pimage_data = rotated_data;
+            *pimage_x = image_y;
+            *pimage_y = image_x;
+        }
+    }
+}
+
 void make_image(Image *z, int image_x, int image_y, uint8 *image_data, BOOL image_loaded_as_rgb, int image_n)
 {
    int i,j,k,ymin=0,ymax=256*8-1;
@@ -526,6 +563,7 @@
          } else {
             // post-process the image into the right format
             f->image = (Image *) malloc(sizeof(*f->image));
+            check_rotate(&x, &y, &data);
             make_image(f->image, x, y,data, loaded_as_rgb, n);
             barrier();
             f->status = LOAD_available;
@@ -665,6 +703,7 @@
    "CTRL-I: launch new viewer instance\n"
 ;
 
+void stb_from_utf8_multi(stb__wchar *out, char *in, int max_out);
 // draw the help text semi-prettily
 // originally this was to try to avoid having to darken the image
 // that it's rendered over, but I couldn't make that work, and with
@@ -673,6 +712,8 @@
 void draw_nice(HDC hdc, char *text, RECT *rect, uint flags)
 {
    int i,j;
+   static stb__wchar wbuffer[1024];
+   stb_from_utf8_multi(wbuffer, text, 1024);
    SetTextColor(hdc, RGB(80,80,80));
    for (i=2; i >= 1; i -= 1)
    for (j=2; j >= 1; j -= 1)
@@ -681,10 +722,10 @@
       RECT r = { rect->left+i, rect->top+j, rect->right+i, rect->bottom + j };
       if (i == 1 && j == 1)
          SetTextColor(hdc, RGB(0,0,0));
-      DrawText(hdc, text, -1, &r, flags);
+      DrawTextW(hdc, wbuffer, -1, &r, flags);
    }
    SetTextColor(hdc, RGB(255,255,255));
-   DrawText(hdc, text, -1, rect, flags);
+   DrawTextW(hdc, wbuffer, -1, rect, flags);
 }
 
 // cached error message for most recent image
@@ -704,7 +745,7 @@
 }
 
 HFONT label_font;
-int label_font_height=12;
+int label_font_height=18;
 
 // build the font for the filename label
 void build_label_font(void)
@@ -771,6 +812,7 @@
       RECT z;
       HFONT old = NULL;
       char buffer[1024];
+      stb__wchar wbuffer[1024];
       char *name = cur_filename ? cur_filename : "(none)";
       if (fileinfo) {
          if (recursive)
@@ -779,13 +821,14 @@
             sprintf(buffer, "%s ( %d / %d )", name, cur_loc+1, stb_arr_len(fileinfo));
          name = buffer;
       }
+      stb_from_utf8_multi(wbuffer, name, 1024);
 
       if (label_font) old = SelectObject(hdc, label_font);
 
       // get rect around label so we can draw it ourselves, because
       // the DrawText() one is poorly sized
 
-      GetTextExtentPoint32(hdc, name, strlen(name), &size);
+      GetTextExtentPoint32W(hdc, wbuffer, wcslen(wbuffer), &size);
       z.left = rect.left+1;
       z.bottom = rect.bottom+1;
       z.top = z.bottom - size.cy - 4;
@@ -794,7 +837,7 @@
       FillRect(hdc, &z, b);
       z.bottom -= 2; // extra padding on bottom because it's at edge of window
       SetTextColor(hdc, RGB(255,255,255));
-      DrawText(hdc, name, -1, &z, DT_SINGLELINE | DT_CENTER | DT_VCENTER);
+      DrawTextW(hdc, wbuffer, -1, &z, DT_SINGLELINE | DT_CENTER | DT_VCENTER);
       if (old) SelectObject(hdc, old);
    }
 
@@ -1290,6 +1333,32 @@
 
 char *open_filter = "Image Files\0*.jpg;*.jpeg;*.png;*.bmp;*.tga;*.hdr;*.spk\0";
 
+int has_img_file(const char *path, const char *subdir)
+{
+   char **image_files; // stb_arr (dynamic array type) of filenames
+   static char fullpath[4096];
+   int i;
+
+   if (path[strlen(path) - 1] == '/')
+   sprintf(fullpath, "%s%s", path, subdir);
+   else
+   sprintf(fullpath, "%s/%s", path, subdir);
+
+   if (recursive)
+      image_files = stb_readdir_recursive(fullpath, open_filter + 12);
+   else
+      image_files = stb_readdir_files_mask(fullpath, open_filter + 12);
+
+   if (image_files == NULL)
+      return FALSE;
+
+   for (i=0; i < stb_arr_len(image_files); ++i)
+      free(image_files[i]); // allocated by stb_readdir
+   stb_arr_free(image_files); 
+
+   return TRUE;
+}
+
 // build a filelist for the current directory
 void init_filelist(void)
 {
@@ -2078,7 +2147,7 @@
                unsigned char curc[6];
                int new_border;
                int old_cubic = upsample_cubic;
-               memcpy(cur, alpha_background, 6);
+               memcpy(curc, alpha_background, 6);
 
                // load the settings back out of the dialog box
                for (i=0; i < 6; ++i)
@@ -2332,6 +2401,7 @@
                break;
 
             case ' ': // space
+            case '\r': // enter
                advance(1);
                break;
 
@@ -2352,6 +2422,11 @@
                   KillTimer(win,0);
                break;
 
+            case 'r':
+            case 'R':
+               autorotate = (autorotate + 1) % 3;
+               break;
+
             case '.': {
                char buffer[512];
                strcpy(buffer, path_to_file);
@@ -2360,6 +2435,7 @@
                stb_splitpath(path_to_file, buffer, STB_PATH);
                if (recursive)
                   init_filelist();
+			   advance(0);
                break;
             }
 
@@ -2384,15 +2460,53 @@
                  | (GetKeyState(VK_MENU   ) < 0 ? MY_ALT  : 0);
          code += wParam;
          switch (code) {
-            case VK_RIGHT:
             case VK_NUMPAD6:
                advance(1);
                break;
-            case VK_LEFT:
             case VK_NUMPAD4:
                advance(-1);
                break;
 
+            case VK_HOME:
+            case VK_PRIOR:
+            case VK_NEXT:
+            case VK_END:
+               {
+                RECT rect;
+                int deltax, deltay;
+                int cx, cy;
+                cx = GetSystemMetrics(SM_CXSCREEN);
+                cy = GetSystemMetrics(SM_CYSCREEN);
+                deltax = (code == VK_END) ? -cx : (code == VK_HOME) ? cx : 0;
+                deltay = (code == VK_PRIOR) ? cy : (code == VK_NEXT) ? -cy : 0;
+                GetWindowRect(win, &rect);
+                if (rect.left + deltax >= cx - FRAME ||
+                    rect.top  + deltay >= cy - FRAME ||
+                    rect.right + deltax <= FRAME ||
+                    rect.bottom + deltay <= FRAME ) {
+                    if (code == VK_HOME || code == VK_PRIOR)
+                        advance(-1);
+                    else
+                        advance(1);
+                }
+                else
+                    MoveWindow(win, rect.left + deltax, rect.top + deltay, rect.right - rect.left, rect.bottom - rect.top, TRUE);
+               }
+               break;
+
+            case VK_LEFT:
+            case VK_RIGHT:
+            case VK_UP:
+            case VK_DOWN: {
+                RECT rect;
+                int deltax, deltay, step = 20;
+                deltax = (code == VK_LEFT) ? -step : (code == VK_RIGHT) ? step : 0;
+                deltay = (code == VK_UP) ? step : (code == VK_DOWN) ? -step : 0;
+                GetWindowRect(win, &rect);
+                MoveWindow(win, rect.left + deltax, rect.top + deltay, rect.right - rect.left, rect.bottom - rect.top, TRUE);
+                break;
+            }
+
             case VK_F1:
             case 'H':
             case 'H' | MY_SHIFT:
@@ -2486,6 +2600,60 @@
                break;
             }
 
+            case 'B' | MY_ALT:
+            case 'F' | MY_ALT: {
+                static int stat = 0;
+                int frac = 4;
+                int adv;
+                int n;
+                int santinel;
+                char buffer[512], **subdir;
+
+                if (code == ('B' | MY_ALT))
+                    adv = -1;
+                else
+                    adv = 1;
+                stat += adv;
+                if (stat < 0 || stat >= frac) {
+                    stat += frac * -adv;
+
+                    recursive = TRUE;
+                    strcpy(buffer, path_to_file);
+                    if (buffer[strlen(buffer)-1] == '/')
+                        buffer[strlen(buffer)-1] = 0;
+                    stb_splitpath(path_to_file, buffer, STB_PATH);
+                    subdir = stb_readdir_subdirs(path_to_file);
+                    if (subdir) {
+                    for (n = stb_arr_len(subdir)-1; n >= 0; --n)
+                        if (!strcmp(subdir[n], buffer))
+                            break;
+                    santinel = n;
+                    do {
+                    n += adv;
+                    if (n < 0)
+                        n += stb_arr_len(subdir);
+                    else if (n >= stb_arr_len(subdir))
+                        n -= stb_arr_len(subdir);
+                    if (n == santinel)
+                        break;
+                    } while (!has_img_file(path_to_file, subdir[n]));
+                    if (n != santinel)
+                    strcpy(path_to_file, subdir[n]);
+                    stb_readdir_free(subdir);
+                    }
+                    init_filelist();
+                    cur_loc = 0;
+                    advance(stb_arr_len(fileinfo) * stat / frac);
+                } else {
+                    if (fileinfo == NULL)
+                        init_filelist();
+                    n = stb_arr_len(fileinfo);
+                    advance((n * stat / frac) - cur_loc);
+                }
+
+                break;
+            }
+
             case 'I' | MY_CTRL: {
                // not sure which of these is smaller
                #if 0
@@ -2500,10 +2668,13 @@
                   CreateProcess(NULL, buffer, NULL, NULL, FALSE, DETACHED_PROCESS, NULL, NULL, &si, &pi);
                #else
                   char buffer[MAX_PATH],filename[1024] = {'\"'};
+                  stb__wchar buf1[MAX_PATH], buf2[1024];
                   GetModuleFileName(NULL, buffer, sizeof(buffer));
                   stb_fullpath(filename+1, sizeof(filename)-2, source_c->filename);
                   strcat(filename, "\"");
-                  _spawnl(_P_NOWAIT, buffer, buffer, filename, NULL);
+                  stb_from_utf8_multi(buf1, buffer, sizeof(buf1));
+                  stb_from_utf8_multi(buf2, filename, sizeof(buf2));
+                  _wspawnl(_P_NOWAIT, buf1, buf1, buf2, NULL);
                #endif
                break;
             }
@@ -2759,6 +2930,7 @@
    // create the source image by converting the image data to BGR,
    // pre-blending alpha
    source = malloc(sizeof(*source));
+   check_rotate(&image_x, &image_y, &image_data);
    make_image(source, image_x, image_y, image_data, image_loaded_as_rgb, image_n);
 
    // create a cache entry in case they start browsing later
