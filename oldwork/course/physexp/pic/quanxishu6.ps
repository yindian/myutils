%!PS-Adobe-2.0 EPSF-2.0
%%Creator: dvips(k) 5.94b Copyright 2004 Radical Eye Software
%%Title: quanxishu6.dvi
%%CreationDate: Wed Apr 19 00:08:04 2006
%BoundingBox: 86 705 99 715
%%BoundingBox: 90 678 224 742
%%DocumentFonts: CMMI10 CMSY7
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips quanxishu6.dvi -E
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2006.04.19:0008
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/p{show}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0 N/Ry 0 N/V{}B/RV/v{
/Ry X/Rx X V}B statusdict begin/product where{pop false[(Display)(NeXT)
(LaserWriter 16/600)]{A length product length le{A length product exch 0
exch getinterval eq{pop true exit}if}{pop}ifelse}forall}{false}ifelse
end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{BDot}imagemask
grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat{BDot}
imagemask grestore}}ifelse B/QV{gsave newpath transform round exch round
exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0 rlineto
fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B/M{S p
delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}B/g{0 M}
B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p -3 w}B/n{
p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{0 S
rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
%!
% PostScript prologue for pstricks.tex.
% Version 97 patch 4, 04/05/10
% For distribution, see pstricks.tex.
%
/tx@Dict 200 dict def tx@Dict begin
/ADict 25 dict def
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Atan { /atan load stopped { pop pop 0 } if } def
/Div { dup 0 eq { pop } { div } ifelse } def
/NET { neg exch neg exch T } def
/Pyth { dup mul exch dup mul add sqrt } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def }
def
/PathLength { flattenpath /z 0 def { /y1 ED /x1 ED /y2 y1 def /x2 x1 def
} { /y ED /x ED PathLength@ } {} { /y y2 def /x x2 def PathLength@ }
/pathforall load stopped { pop pop pop pop } if z } def
/STP { .996264 dup scale } def
/STV { SDict begin normalscale end STP  } def
%
%%-------------- DG begin patch 15 ---------------%%
%/DashLine { dup 0 gt { /a .5 def PathLength exch div } { pop /a 1 def
%PathLength } ifelse /b ED /x ED /y ED /z y x add def b a .5 sub 2 mul y
%mul sub z Div round z mul a .5 sub 2 mul y mul add b exch Div dup y mul
%/y ED x mul /x ED x 0 gt y 0 gt and { [ y x ] 1 a sub y mul } { [ 1 0 ]
%0 } ifelse setdash stroke } def
/DashLine {
  dup 0 gt { /a .5 def PathLength exch div } { pop /a 1 def PathLength } ifelse
  /b ED /x1 ED /y1 ED /x ED /y ED 
  /z y x add y1 add x1 add def
  /Coef b a .5 sub 2 mul y mul sub z Div round 
  z mul a .5 sub 2 mul y mul add b exch Div def 
  /y y Coef mul def /x x Coef mul def /y1 y1 Coef mul def /x1 x1 Coef mul def
  x1 0 gt y1 0 gt x 0 gt y 0 gt and { [ y x y1 x1 ] 1 a sub y mul}
  { [ 1 0] 0 } ifelse setdash stroke
} def
%%-------------- DG end patch 15 ---------------%%
/DotLine { /b PathLength def /a ED /z ED /y CLW def /z y z add def a 0 gt
{ /b b a div def } { a 0 eq { /b b y sub def } { a -3 eq { /b b y add
def } if } ifelse } ifelse [ 0 b b z Div round Div dup 0 le { pop 1 } if
] a 0 gt { 0 } { y 2 div a -2 gt { neg } if } ifelse setdash 1
setlinecap stroke } def
/LineFill { gsave abs CLW add /a ED a 0 dtransform round exch round exch
2 copy idtransform exch Atan rotate idtransform pop /a ED .25 .25
% DG/SR modification begin - Dec. 12, 1997 - Patch 2
%itransform translate pathbbox /y2 ED a Div ceiling cvi /x2 ED /y1 ED a
itransform pathbbox /y2 ED a Div ceiling cvi /x2 ED /y1 ED a
% DG/SR modification end
Div cvi /x1 ED /y2 y2 y1 sub def clip newpath 2 setlinecap systemdict
/setstrokeadjust known { true setstrokeadjust } if x2 x1 sub 1 add { x1
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% a mul y1 moveto 0 y2 rlineto stroke /x1 x1 1 add def } repeat grestore }
% def
a mul y1 moveto 0 y2 rlineto stroke /x1 x1 1 add def } repeat grestore
pop pop } def
% DG/SR modification end
/BeginArrow { ADict begin /@mtrx CM def gsave 2 copy T 2 index sub neg
exch 3 index sub exch Atan rotate newpath } def
/EndArrow { @mtrx setmatrix CP grestore end } def
/Arrow { CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1
scale } if w neg h moveto 0 0 L w h L w neg a neg rlineto gsave fill
grestore } def
/Tbar { CLW mul add /z ED z -2 div CLW 2 div moveto z 0 rlineto stroke 0
CLW moveto } def
/Bracket { CLW mul add dup CLW sub 2 div /x ED mul CLW add /y ED /z CLW 2
div def x neg y moveto x neg CLW 2 div L x CLW 2 div L x y L stroke 0
CLW moveto } def
/RoundBracket { CLW mul add dup 2 div /x ED mul /y ED /mtrx CM def 0 CLW
2 div T x y mul 0 ne { x y scale } if 1 1 moveto .85 .5 .35 0 0 0
curveto -.35 0 -.85 .5 -1 1 curveto mtrx setmatrix stroke 0 CLW moveto }
def
/SD { 0 360 arc fill } def
/EndDot { { /z DS def } { /z 0 def } ifelse /b ED 0 z DS SD b { 0 z DS
CLW sub SD } if 0 DS z add CLW 4 div sub moveto } def
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
/closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
load } if ] cvx newpath 3 1 roll T exec } def
/NArray { aload length 2 div dup dup cvi eq not { exch pop } if /n exch
cvi def } def
/NArray { /f ED counttomark 2 div dup cvi /n ED n eq not { exch pop } if
f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse } def
/Line { NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub
def n { Lineto } repeat CP 4 2 roll ArrowB L pop pop } if } def
/Arcto { /a [ 6 -2 roll ] cvx def a r /arcto load stopped { 5 } { 4 }
ifelse { pop } repeat a } def
/CheckClosed { dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
and { pop pop /n n 1 sub def } if } def
/Polygon { NArray n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop }
repeat } { n 3 gt { CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1
ED /x1 ED x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1 add 2 div def x1 y1
moveto /n n 2 sub def n { Lineto } repeat x1 y1 x0 y0 6 4 roll Lineto
Lineto pop pop closepath } ifelse } def
/Diamond { /mtrx CM def T rotate /h ED /w ED dup 0 eq { pop } { CLW mul
neg /d ED /a w h Atan def /h d a sin Div h add def /w d a cos Div w add
def } ifelse mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2
div /ArrowA { moveto } def /ArrowB { } def false Line closepath mtrx
setmatrix } def
% DG modification begin - Jan. 15, 1997
%/Triangle { /mtrx CM def translate rotate /h ED 2 div /w ED dup 0 eq {
%pop } { CLW mul /d ED /h h d w h Atan sin Div sub def /w w d h w Atan 2
%div dup cos exch sin Div mul sub def } ifelse mark 0 d w neg d 0 h w d 0
%d /ArrowA { moveto } def /ArrowB { } def false Line closepath mtrx
%setmatrix } def
/Triangle { /mtrx CM def translate rotate /h ED 2 div /w ED dup
CLW mul /d ED /h h d w h Atan sin Div sub def /w w d h w Atan 2
div dup cos exch sin Div mul sub def mark 0 d w neg d 0 h w d 0
d /ArrowA { moveto } def /ArrowB { } def false Line closepath mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
setmatrix pop } def
% DG/SR modification end
/CCA { /y ED /x ED 2 copy y sub /dy1 ED x sub /dx1 ED /l1 dx1 dy1 Pyth
def } def
/CCA { /y ED /x ED 2 copy y sub /dy1 ED x sub /dx1 ED /l1 dx1 dy1 Pyth
def } def
/CC { /l0 l1 def /x1 x dx sub def /y1 y dy sub def /dx0 dx1 def /dy0 dy1
def CCA /dx dx0 l1 c exp mul dx1 l0 c exp mul add def /dy dy0 l1 c exp
mul dy1 l0 c exp mul add def /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos
abs b exp a mul dx dy Pyth Div 2 div def /x2 x l0 dx mul m mul sub def
/y2 y l0 dy mul m mul sub def /dx l1 dx mul m mul neg def /dy l1 dy mul
m mul neg def } def
/IC { /c c 1 add def c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if }
ifelse /a a 2 mul 3 div 45 cos b exp div def CCA /dx 0 def /dy 0 def }
def
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
/OpenCurve { NArray n 3 lt { n { pop pop } repeat } { BOC /n n 3 sub def
    n { NC } repeat EOC } ifelse } def
/AltCurve { { false NArray n 2 mul 2 roll [ n 2 mul 3 sub 1 roll ] aload
/Points ED n 2 mul -2 roll } { false NArray } ifelse n 4 lt { n { pop
pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse } def
/ClosedCurve { NArray n 3 lt { n { pop pop } repeat } { n 3 gt {
CheckClosed } if 6 copy n 2 mul 6 add 6 roll IC CC x y moveto n { NC }
repeat closepath pop pop } ifelse } def
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore }
def
/FontDot { DS 2 mul dup matrix scale matrix concatmatrix exch matrix
rotate matrix concatmatrix exch findfont exch makefont setfont } def
/Rect { x1 y1 y2 add 2 div moveto x1 y2 lineto x2 y2 lineto x2 y1 lineto
x1 y1 lineto closepath } def
/OvalFrame { x1 x2 eq y1 y2 eq or { pop pop x1 y1 moveto x2 y2 L } { y1
y2 sub abs x1 x2 sub abs 2 copy gt { exch pop } { pop } ifelse 2 div
exch { dup 3 1 roll mul exch } if 2 copy lt { pop } { exch pop } ifelse
/b ED x1 y1 y2 add 2 div moveto x1 y2 x2 y2 b arcto x2 y2 x2 y1 b arcto
x2 y1 x1 y1 b arcto x1 y1 x1 y2 b arcto 16 { pop } repeat closepath }
ifelse } def
/Frame { CLW mul /a ED 3 -1 roll 2 copy gt { exch } if a sub /y2 ED a add
/y1 ED 2 copy gt { exch } if a sub /x2 ED a add /x1 ED 1 index 0 eq {
pop pop Rect } { OvalFrame } ifelse } def
/BezierNArray { /f ED counttomark 2 div dup cvi /n ED n eq not { exch pop
} if n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat f { ]
aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse } def
/OpenBezier { BezierNArray n 1 eq { pop pop } { ArrowA n 4 sub 3 idiv { 6
2 roll 4 2 roll curveto } repeat 6 2 roll 4 2 roll ArrowB curveto }
ifelse } def
/ClosedBezier { BezierNArray n 1 eq { pop pop } { moveto n 1 sub 3 idiv {
6 2 roll 4 2 roll curveto } repeat closepath } ifelse } def
/BezierShowPoints { gsave Points aload length 2 div cvi /n ED moveto n 1
sub { lineto } repeat CLW 2 div SLW [ 4 4 ] 0 setdash stroke grestore }
def
/Parab { /y0 exch def /x0 exch def /y1 exch def /x1 exch def /dx x0 x1
sub 3 div def /dy y0 y1 sub 3 div def x0 dx sub y0 dy add x1 y1 ArrowA
x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB curveto /Points [ x1 y1 x0
y0 x0 2 mul x1 sub y1 ] def } def
/Grid { newpath /a 4 string def /b ED /c ED /n ED cvi dup 1 lt { pop 1 }
if /s ED s div dup 0 eq { pop 1 } if /dy ED s div dup 0 eq { pop 1 } if
/dx ED dy div round dy mul /y0 ED dx div round dx mul /x0 ED dy div
round cvi /y2 ED dx div round cvi /x2 ED dy div round cvi /y1 ED dx div
round cvi /x1 ED /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def /w x2 x1 sub
0 gt { 1 } { -1 } ifelse def b 0 gt { /z1 b 4 div CLW 2 div add def
/Helvetica findfont b scalefont setfont /b b .95 mul CLW 2 div add def }
if systemdict /setstrokeadjust known { true setstrokeadjust /t { } def }
{ /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
exch itransform } bind def } ifelse gsave n 0 gt { 1 setlinecap [ 0 dy n
div ] dy n div 2 div setdash } { 2 setlinecap } ifelse /i x1 def /f y1
dy mul n 0 gt { dy n div 2 div h mul sub } if def /g y2 dy mul n 0 gt {
dy n div 2 div h mul add } if def x2 x1 sub w mul 1 add dup 1000 gt {
pop 1000 } if { i dx mul dup y0 moveto b 0 gt { gsave c i a cvs dup
stringwidth pop /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse h 0 gt {b neg}
{z1} ifelse rmoveto show grestore } if dup t f moveto g t L stroke /i i
w add def } repeat grestore gsave n 0 gt
% DG/SR modification begin - Nov. 7, 1997 - Patch 1
%{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
{ 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
% DG/SR modification end
{ 2 setlinecap } ifelse /i y1 def /f x1 dx mul
n 0 gt { dx n div 2 div w mul sub } if def /g x2 dx mul n 0 gt { dx n
div 2 div w mul add } if def y2 y1 sub h mul 1 add dup 1000 gt { pop
1000 } if { newpath i dy mul dup x0 exch moveto b 0 gt { gsave c i a cvs
dup stringwidth pop /z2 ED w 0 gt {z1 z2 add neg} {z1} ifelse h 0 gt
{z1} {b neg} ifelse rmoveto show grestore } if dup f exch t moveto g
exch t L stroke /i i h add def } repeat grestore } def
/ArcArrow { /d ED /b ED /a ED gsave newpath 0 -1000 moveto clip newpath 0
1 0 0 b grestore c mul /e ED pop pop pop r a e d PtoC y add exch x add
exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
mul neg d } def
/Ellipse { /mtrx CM def T scale 0 0 1 5 3 roll arc mtrx setmatrix } def
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
/RotBegin { tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 }
def } if /TMatrix [ TMatrix CM ] cvx def /a ED a Rot /RAngle [ RAngle
dup a add ] cvx def } def
/RotEnd { /TMatrix [ TMatrix setmatrix ] cvx def /RAngle [ RAngle pop ]
cvx def } def
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
/Uput { /a ED add 2 div /h ED 2 div /w ED /s a sin def /c a cos def /b s
abs c abs 2 copy gt dup /q ED { pop } { exch pop } ifelse def /w1 c b
div w mul def /h1 s b div h mul def q { w1 abs w sub dup c mul abs } {
h1 abs h sub dup s mul abs } ifelse } def
/UUput { /z ED abs /y ED /x ED q { x s div c mul abs y gt } { x c div s
mul abs y gt } ifelse { x x mul y y mul sub z z mul add sqrt z add } { q
{ x s div } { x c div } ifelse abs } ifelse a PtoC h1 add exch w1 add
exch } def
/BeginOL { dup (all) eq exch TheOL eq or { IfVisible not { Visible
/IfVisible true def } if } { IfVisible { Invisible /IfVisible false def
} if } ifelse } def
/InitOL { /OLUnit [ 3000 3000 matrix defaultmatrix dtransform ] cvx def
/Visible { CP OLUnit idtransform T moveto } def /Invisible { CP OLUnit
neg exch neg exch idtransform T moveto } def /BOL { BeginOL } def
/IfVisible true def } def
end
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
%!PS-Adobe-2.0
%%Title: Dot Font for PSTricks
%%Creator: Timothy Van Zandt <tvz@Princeton.EDU>
%%Creation Date: May 7, 1993
%% Version 97 patch 1, 99/12/16
%% Modified by Etienne Riga <etienne.riga@skynet.be> - Dec. 16, 1999
%% to add /Diamond, /SolidDiamond and /BoldDiamond
10 dict dup begin
  /FontType 3 def
  /FontMatrix [ .001 0 0 .001 0 0 ] def
  /FontBBox [ 0 0 0 0 ] def
  /Encoding 256 array def
  0 1 255 { Encoding exch /.notdef put } for
  Encoding
    dup (b) 0 get /Bullet put
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
% DG/SR modification begin - Dec. 16, 1999 - From Etienne Riga
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
% DG/SR modification end
  /Metrics 13 dict def
  Metrics begin
    /Bullet        1000   def
    /Circle        1000   def
    /BoldCircle    1000   def
    /SolidTriangle 1344   def
    /Triangle      1344   def
    /BoldTriangle  1344   def
    /SolidSquare    886   def
    /Square         886   def
    /BoldSquare     886   def
    /SolidPentagon 1093.2 def
    /Pentagon      1093.2 def
    /BoldPentagon  1093.2 def
% DG/SR modification begin - Dec. 16, 1999 - From Etienne Riga
    /SolidDiamond  1008   def
    /Diamond       1008   def
    /BoldDiamond   1008   def
% DG/SR modification end
    /.notdef 0 def
  end
  /BBoxes 13 dict def
  BBoxes begin
    /Circle        { -550 -550 550 550 } def
    /BoldCircle    /Circle load def
    /Bullet        /Circle load def
    /Triangle      { -571.5 -330 571.5 660 } def
    /BoldTriangle  /Triangle load def
    /SolidTriangle /Triangle load def
    /Square        { -450 -450 450 450 } def
    /BoldSquare    /Square load def
    /SolidSquare   /Square load def
    /Pentagon      { -546.6 -465 546.6 574.7 } def
    /BoldPentagon  /Pentagon load def
    /SolidPentagon /Pentagon load def
% DG/SR modification begin - Dec. 16, 1999 - From Etienne Riga
    /Diamond       { -428.5 -742.5 428.5 742.5 } def
    /BoldDiamond   /Diamond load def
    /SolidDiamond  /Diamond load def
% DG/SR modification end
    /.notdef { 0 0 0 0 } def
  end
  /CharProcs 20 dict def
  CharProcs begin
    /Adjust {
      2 copy dtransform floor .5 add exch floor .5 add exch idtransform
      3 -1 roll div 3 1 roll exch div exch scale
    } def
    /CirclePath    { 0 0 500 0 360 arc closepath } def
    /Bullet        { 500 500 Adjust CirclePath fill } def
    /Circle        { 500 500 Adjust CirclePath .9 .9 scale CirclePath
                     eofill } def
    /BoldCircle    { 500 500 Adjust CirclePath .8 .8 scale CirclePath
                     eofill } def
    /BoldCircle    { CirclePath .8 .8 scale CirclePath eofill } def
    /TrianglePath  { 0  660 moveto -571.5 -330 lineto 571.5 -330 lineto
                     closepath } def
    /SolidTriangle { TrianglePath fill } def
    /Triangle      { TrianglePath .85 .85 scale TrianglePath eofill } def
    /BoldTriangle  { TrianglePath .7 .7 scale TrianglePath eofill } def
    /SquarePath    { -450 450 moveto 450 450 lineto 450 -450 lineto
                     -450 -450 lineto closepath } def
    /SolidSquare   { SquarePath fill } def
    /Square        { SquarePath .89 .89 scale SquarePath eofill } def
    /BoldSquare    { SquarePath .78 .78 scale SquarePath eofill } def
    /PentagonPath  {
      -337.8 -465   moveto
       337.8 -465   lineto
       546.6  177.6 lineto
         0    574.7 lineto
      -546.6  177.6 lineto
      closepath
    } def
    /SolidPentagon { PentagonPath fill } def
    /Pentagon      { PentagonPath .89 .89 scale PentagonPath eofill } def
    /BoldPentagon  { PentagonPath .78 .78 scale PentagonPath eofill } def
% DG/SR modification begin - Dec. 16, 1999 - From Etienne Riga
    /DiamondPath   { 0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto
                     428.5 0 lineto closepath } def
    /SolidDiamond  { DiamondPath fill } def
    /Diamond       { DiamondPath .85 .85 scale DiamondPath eofill } def
    /BoldDiamond   { DiamondPath .7 .7 scale DiamondPath eofill } def
% DG/SR modification end
    /.notdef { } def
  end
  /BuildGlyph {
    exch
    begin
      Metrics 1 index get exec 0
      BBoxes 3 index get exec
      setcachedevice
      CharProcs begin load exec end
    end
  } def
  /BuildChar {
    1 index /Encoding get exch get
    1 index /BuildGlyph get exec
  } bind def
end
/PSTricksDotFont exch definefont pop
%END pst-dots.pro

%%EndProcSet
%%BeginProcSet: pst-node.pro 0 0
%!
% PostScript prologue for pst-node.tex.
% Version 97 patch 1, 97/05/09.
% For distribution, see pstricks.tex.
%
/tx@NodeDict 400 dict def tx@NodeDict begin
tx@Dict begin /T /translate load def end
/NewNode { gsave /next ED dict dup 3 1 roll def exch { dup 3 1 roll def }
if begin tx@Dict begin STV CP T exec end /NodeMtrx CM def next end
grestore } def
/InitPnode { /Y ED /X ED /NodePos { NodeSep Cos mul NodeSep Sin mul } def
} def
/InitCnode { /r ED /Y ED /X ED /NodePos { NodeSep r add dup Cos mul exch
Sin mul } def } def
/GetRnodePos { Cos 0 gt { /dx r NodeSep add def } { /dx l NodeSep sub def
} ifelse Sin 0 gt { /dy u NodeSep add def } { /dy d NodeSep sub def }
ifelse dx Sin mul abs dy Cos mul abs gt { dy Cos mul Sin div dy } { dx
dup Sin mul Cos Div } ifelse } def
/InitRnode { /Y ED /X ED X sub /r ED /l X neg def Y add neg /d ED Y sub
/u ED /NodePos { GetRnodePos } def } def
/DiaNodePos { w h mul w Sin mul abs h Cos mul abs add Div NodeSep add dup
Cos mul exch Sin mul } def
/TriNodePos { Sin s lt { d NodeSep sub dup Cos mul Sin Div exch } { w h
mul w Sin mul h Cos abs mul add Div NodeSep add dup Cos mul exch Sin mul
} ifelse } def
/InitTriNode { sub 2 div exch 2 div exch 2 copy T 2 copy 4 index index /d
ED pop pop pop pop -90 mul rotate /NodeMtrx CM def /X 0 def /Y 0 def d
sub abs neg /d ED d add /h ED 2 div h mul h d sub Div /w ED /s d w Atan
sin def /NodePos { TriNodePos } def } def
/OvalNodePos { /ww w NodeSep add def /hh h NodeSep add def Sin ww mul Cos
hh mul Atan dup cos ww mul exch sin hh mul } def
/GetCenter { begin X Y NodeMtrx transform CM itransform end } def
/XYPos { dup sin exch cos Do /Cos ED /Sin ED /Dist ED Cos 0 gt { Dist
Dist Sin mul Cos div } { Cos 0 lt { Dist neg Dist Sin mul Cos div neg }
{ 0 Dist Sin mul } ifelse } ifelse Do } def
/GetEdge { dup 0 eq { pop begin 1 0 NodeMtrx dtransform CM idtransform
exch atan sub dup sin /Sin ED cos /Cos ED /NodeSep ED NodePos NodeMtrx
dtransform CM idtransform end } { 1 eq {{exch}} {{}} ifelse /Do ED pop
XYPos } ifelse } def
/AddOffset { 1 index 0 eq { pop pop } { 2 copy 5 2 roll cos mul add 4 1
roll sin mul sub exch } ifelse } def
/GetEdgeA { NodeSepA AngleA NodeA NodeSepTypeA GetEdge OffsetA AngleA
AddOffset yA add /yA1 ED xA add /xA1 ED } def
/GetEdgeB { NodeSepB AngleB NodeB NodeSepTypeB GetEdge OffsetB AngleB
AddOffset yB add /yB1 ED xB add /xB1 ED } def
/GetArmA { ArmTypeA 0 eq { /xA2 ArmA AngleA cos mul xA1 add def /yA2 ArmA
AngleA sin mul yA1 add def } { ArmTypeA 1 eq {{exch}} {{}} ifelse /Do ED
ArmA AngleA XYPos OffsetA AngleA AddOffset yA add /yA2 ED xA add /xA2 ED
} ifelse } def
/GetArmB { ArmTypeB 0 eq { /xB2 ArmB AngleB cos mul xB1 add def /yB2 ArmB
AngleB sin mul yB1 add def } { ArmTypeB 1 eq {{exch}} {{}} ifelse /Do ED
ArmB AngleB XYPos OffsetB AngleB AddOffset yB add /yB2 ED xB add /xB2 ED
} ifelse } def
/InitNC { /b ED /a ED /NodeSepTypeB ED /NodeSepTypeA ED /NodeSepB ED
/NodeSepA ED /OffsetB ED /OffsetA ED tx@NodeDict a known tx@NodeDict b
known and dup { /NodeA a load def /NodeB b load def NodeA GetCenter /yA
ED /xA ED NodeB GetCenter /yB ED /xB ED } if } def
/LPutLine { 4 copy 3 -1 roll sub neg 3 1 roll sub Atan /NAngle ED 1 t sub
mul 3 1 roll 1 t sub mul 4 1 roll t mul add /Y ED t mul add /X ED } def
/LPutLines { mark LPutVar counttomark 2 div 1 sub /n ED t floor dup n gt
{ pop n 1 sub /t 1 def } { dup t sub neg /t ED } ifelse cvi 2 mul { pop
} repeat LPutLine cleartomark } def
/BezierMidpoint { /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED /y0 ED /x0 ED
/t ED /cx x1 x0 sub 3 mul def /cy y1 y0 sub 3 mul def /bx x2 x1 sub 3
mul cx sub def /by y2 y1 sub 3 mul cy sub def /ax x3 x0 sub cx sub bx
sub def /ay y3 y0 sub cy sub by sub def ax t 3 exp mul bx t t mul mul
add cx t mul add x0 add ay t 3 exp mul by t t mul mul add cy t mul add
y0 add 3 ay t t mul mul mul 2 by t mul mul add cy add 3 ax t t mul mul
mul 2 bx t mul mul add cx add atan /NAngle ED /Y ED /X ED } def
/HPosBegin { yB yA ge { /t 1 t sub def } if /Y yB yA sub t mul yA add def
} def
/HPosEnd { /X Y yyA sub yyB yyA sub Div xxB xxA sub mul xxA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/HPutLine { HPosBegin /yyA ED /xxA ED /yyB ED /xxB ED HPosEnd  } def
/HPutLines { HPosBegin yB yA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { dup Y check { exit
} { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark HPosEnd 
} def
/VPosBegin { xB xA lt { /t 1 t sub def } if /X xB xA sub t mul xA add def
} def
/VPosEnd { /Y X xxA sub xxB xxA sub Div yyB yyA sub mul yyA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/VPutLine { VPosBegin /yyA ED /xxA ED /yyB ED /xxB ED VPosEnd  } def
/VPutLines { VPosBegin xB xA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { 1 index X check {
exit } { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark
VPosEnd  } def
/HPutCurve { gsave newpath /SaveLPutVar /LPutVar load def LPutVar 8 -2
roll moveto curveto flattenpath /LPutVar [ {} {} {} {} pathforall ] cvx
def grestore exec /LPutVar /SaveLPutVar load def } def
/NCCoor { /AngleA yB yA sub xB xA sub Atan def /AngleB AngleA 180 add def
GetEdgeA GetEdgeB /LPutVar [ xB1 yB1 xA1 yA1 ] cvx def /LPutPos {
LPutVar LPutLine } def /HPutPos { LPutVar HPutLine } def /VPutPos {
LPutVar VPutLine } def LPutVar } def
/NCLine { NCCoor tx@Dict begin ArrowA CP 4 2 roll ArrowB lineto pop pop
end } def
/NCLines { false NArray n 0 eq { NCLine } { 2 copy yA sub exch xA sub
Atan /AngleA ED n 2 mul dup index exch index yB sub exch xB sub Atan
/AngleB ED GetEdgeA GetEdgeB /LPutVar [ xB1 yB1 n 2 mul 4 add 4 roll xA1
yA1 ] cvx def mark LPutVar tx@Dict begin false Line end /LPutPos {
LPutLines } def /HPutPos { HPutLines } def /VPutPos { VPutLines } def }
ifelse } def
/NCCurve { GetEdgeA GetEdgeB xA1 xB1 sub yA1 yB1 sub Pyth 2 div dup 3 -1
roll mul /ArmA ED mul /ArmB ED /ArmTypeA 0 def /ArmTypeB 0 def GetArmA
GetArmB xA2 yA2 xA1 yA1 tx@Dict begin ArrowA end xB2 yB2 xB1 yB1 tx@Dict
begin ArrowB end curveto /LPutVar [ xA1 yA1 xA2 yA2 xB2 yB2 xB1 yB1 ]
cvx def /LPutPos { t LPutVar BezierMidpoint } def /HPutPos { { HPutLines
} HPutCurve } def /VPutPos { { VPutLines } HPutCurve } def } def
/NCAngles { GetEdgeA GetEdgeB GetArmA GetArmB /mtrx AngleA matrix rotate
def xA2 yA2 mtrx transform pop xB2 yB2 mtrx transform exch pop mtrx
itransform /y0 ED /x0 ED mark ArmB 0 ne { xB1 yB1 } if xB2 yB2 x0 y0 xA2
yA2 ArmA 0 ne { xA1 yA1 } if tx@Dict begin false Line end /LPutVar [ xB1
yB1 xB2 yB2 x0 y0 xA2 yA2 xA1 yA1 ] cvx def /LPutPos { LPutLines } def
/HPutPos { HPutLines } def /VPutPos { VPutLines } def } def
/NCAngle { GetEdgeA GetEdgeB GetArmB /mtrx AngleA matrix rotate def xB2
yB2 mtrx itransform pop xA1 yA1 mtrx itransform exch pop mtrx transform
/y0 ED /x0 ED mark ArmB 0 ne { xB1 yB1 } if xB2 yB2 x0 y0 xA1 yA1
tx@Dict begin false Line end /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA1 yA1 ]
cvx def /LPutPos { LPutLines } def /HPutPos { HPutLines } def /VPutPos {
VPutLines } def } def
/NCBar { GetEdgeA GetEdgeB GetArmA GetArmB /mtrx AngleA matrix rotate def
xA2 yA2 mtrx itransform pop xB2 yB2 mtrx itransform pop sub dup 0 mtrx
transform 3 -1 roll 0 gt { /yB2 exch yB2 add def /xB2 exch xB2 add def }
{ /yA2 exch neg yA2 add def /xA2 exch neg xA2 add def } ifelse mark ArmB
0 ne { xB1 yB1 } if xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if tx@Dict
begin false Line end /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx
def /LPutPos { LPutLines } def /HPutPos { HPutLines } def /VPutPos {
VPutLines } def } def
/NCDiag { GetEdgeA GetEdgeB GetArmA GetArmB mark ArmB 0 ne { xB1 yB1 } if
xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if tx@Dict begin false Line end
/LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def /LPutPos {
LPutLines } def /HPutPos { HPutLines } def /VPutPos { VPutLines } def }
def
/NCDiagg { GetEdgeA GetArmA yB yA2 sub xB xA2 sub Atan 180 add /AngleB ED
GetEdgeB mark xB1 yB1 xA2 yA2 ArmA 0 ne { xA1 yA1 } if tx@Dict begin
false Line end /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def /LPutPos {
LPutLines } def /HPutPos { HPutLines } def /VPutPos { VPutLines } def }
def
/NCLoop { GetEdgeA GetEdgeB GetArmA GetArmB /mtrx AngleA matrix rotate
def xA2 yA2 mtrx transform loopsize add /yA3 ED /xA3 ED /xB3 xB2 yB2
mtrx transform pop def xB3 yA3 mtrx itransform /yB3 ED /xB3 ED xA3 yA3
mtrx itransform /yA3 ED /xA3 ED mark ArmB 0 ne { xB1 yB1 } if xB2 yB2
xB3 yB3 xA3 yA3 xA2 yA2 ArmA 0 ne { xA1 yA1 } if tx@Dict begin false
Line end /LPutVar [ xB1 yB1 xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 xA1 yA1 ]
cvx def /LPutPos { LPutLines } def /HPutPos { HPutLines } def /VPutPos {
VPutLines } def } def
% DG/SR modification begin - May 9, 1997 - Patch 1
%/NCCircle { 0 0 NodesepA nodeA \tx@GetEdge pop xA sub 2 div dup 2 exp r
%r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
%exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
%mul add dup 5 1 roll 90 sub \tx@PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
/NCCircle { NodeSepA 0 NodeA 0 GetEdge pop 2 div dup 2 exp r
r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
mul add dup 5 1 roll 90 sub PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
% DG/SR modification end
} def /HPutPos { LPutPos } def /VPutPos { LPutPos } def r AngleA 90 sub a add
AngleA 270 add a sub tx@Dict begin /angleB ED /angleA ED /r ED /c 57.2957 r
Div def /y ED /x ED } def
/NCBox { /d ED /h ED /AngleB yB yA sub xB xA sub Atan def /AngleA AngleB
180 add def GetEdgeA GetEdgeB /dx d AngleB sin mul def /dy d AngleB cos
mul neg def /hx h AngleB sin mul neg def /hy h AngleB cos mul def
/LPutVar [ xA1 hx add yA1 hy add xB1 hx add yB1 hy add xB1 dx add yB1 dy
add xA1 dx add yA1 dy add ] cvx def /LPutPos { LPutLines } def /HPutPos
{ xB yB xA yA LPutLine } def /VPutPos { HPutPos } def mark LPutVar
tx@Dict begin false Polygon end } def
/NCArcBox { /l ED neg /d ED /h ED /a ED /AngleA yB yA sub xB xA sub Atan
def /AngleB AngleA 180 add def /tA AngleA a sub 90 add def /tB tA a 2
mul add def /r xB xA sub tA cos tB cos sub Div dup 0 eq { pop 1 } if def
/x0 xA r tA cos mul add def /y0 yA r tA sin mul add def /c 57.2958 r div
def /AngleA AngleA a sub 180 add def /AngleB AngleB a add 180 add def
GetEdgeA GetEdgeB /AngleA tA 180 add yA yA1 sub xA xA1 sub Pyth c mul
sub def /AngleB tB 180 add yB yB1 sub xB xB1 sub Pyth c mul add def l 0
eq { x0 y0 r h add AngleA AngleB arc x0 y0 r d add AngleB AngleA arcn }
{ x0 y0 translate /tA AngleA l c mul add def /tB AngleB l c mul sub def
0 0 r h add tA tB arc r h add AngleB PtoC r d add AngleB PtoC 2 copy 6 2
roll l arcto 4 { pop } repeat r d add tB PtoC l arcto 4 { pop } repeat 0
0 r d add tB tA arcn r d add AngleA PtoC r h add AngleA PtoC 2 copy 6 2
roll l arcto 4 { pop } repeat r h add tA PtoC l arcto 4 { pop } repeat }
ifelse closepath /LPutVar [ x0 y0 r AngleA AngleB h d ] cvx def /LPutPos
{ LPutVar /d ED /h ED /AngleB ED /AngleA ED /r ED /y0 ED /x0 ED t 1 le {
r h add AngleA 1 t sub mul AngleB t mul add dup 90 add /NAngle ED PtoC }
{ t 2 lt { /NAngle AngleB 180 add def r 2 t sub h mul t 1 sub d mul add
add AngleB PtoC } { t 3 lt { r d add AngleB 3 t sub mul AngleA 2 t sub
mul add dup 90 sub /NAngle ED PtoC } { /NAngle AngleA 180 add def r 4 t
sub d mul t 3 sub h mul add add AngleA PtoC } ifelse } ifelse } ifelse
y0 add /Y ED x0 add /X ED } def /HPutPos { LPutPos } def /VPutPos {
LPutPos } def } def
/Tfan { /AngleA yB yA sub xB xA sub Atan def GetEdgeA w xA1 xB sub yA1 yB
sub Pyth Pyth w Div CLW 2 div mul 2 div dup AngleA sin mul yA1 add /yA1
ED AngleA cos mul xA1 add /xA1 ED /LPutVar [ xA1 yA1 m { xB w add yB xB
w sub yB } { xB yB w sub xB yB w add } ifelse xA1 yA1 ] cvx def /LPutPos
{ LPutLines } def /VPutPos@ { LPutVar flag { 8 4 roll pop pop pop pop }
{ pop pop pop pop 4 2 roll } ifelse } def /VPutPos { VPutPos@ VPutLine }
def /HPutPos { VPutPos@ HPutLine } def mark LPutVar tx@Dict begin
/ArrowA { moveto } def /ArrowB { } def false Line closepath end } def
/LPutCoor { NAngle tx@Dict begin /NAngle ED end gsave CM STV CP Y sub neg
exch X sub neg exch moveto setmatrix CP grestore } def
/LPut { tx@NodeDict /LPutPos known { LPutPos } { CP /Y ED /X ED /NAngle 0
def } ifelse LPutCoor  } def
/HPutAdjust { Sin Cos mul 0 eq { 0 } { d Cos mul Sin div flag not { neg }
if h Cos mul Sin div flag { neg } if 2 copy gt { pop } { exch pop }
ifelse } ifelse s add flag { r add neg } { l add } ifelse X add /X ED }
def
/VPutAdjust { Sin Cos mul 0 eq { 0 } { l Sin mul Cos div flag { neg } if
r Sin mul Cos div flag not { neg } if 2 copy gt { pop } { exch pop }
ifelse } ifelse s add flag { d add } { h add neg } ifelse Y add /Y ED }
def
end
% END pst-node.pro

%%EndProcSet
%%BeginProcSet: pst-eqdf.pro 0 0
%!
% PostScript prologue for pst-eqdf.tex.
% Version 2004.11, 2004/11/14
% For distribution, see pstricks.tex.
%
% Dominique Rodriguez
%
%       HISTORY
% 2004/11/14 : correction of a priority problem
%              ^ before unary - (new rule FS)
/tx@EqdfDict 400 dict def tx@EqdfDict begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Pi
/Pi 3.14159265359 def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.11
% E->T|E+T
% T->FS|T*FS                                  %%% NEW 2004/11/14
% FS -> F | +SF | -SF                         %%% NEW 2004/11/14
% F->P|F^P                                    %%% OLD
% F->P|F^SF                                   %%% NEW 2004/11/14  ???? ^FS
% P->(E)|literal
% literal->number|var|var[E]|func(params)%%|-P|+P%%% OLD
% params->E|E,param
%
% E expression, T term, SF signed factor, F factor, P power
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% parser
%% str -> [ LIFO vector ]
/AlgParser { InitParser SetExpr LexStr 0 exch AnalyzeListOfE ExpressionVector /ExpressionVector [] def} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/SetExpr { /ExpressionString exch def } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/InitParser {
  /ExpressionVector [] def  /AddVector [] def
  /AddVectorfree [] def     /MulVector [] def
  /MulVectorfree [] def     /PowVector [] def
  /PowVectorfree [] def     /OpParVector [] def
  /ClParVector [] def       /ParVectorFree [] def
  /BraVector [] def         /SemVector [] def
  /ComVector [] def         /ExpressionVector [] def
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/FLbreak { tst not {/L exch def /F exch def 2 copy L eq exch F eq and /tst exch def} {pop pop}ifelse} def
/Negbreak { tst not { dup 0 lt /tst exch def } if } def
/STOP { tst {TOUF} if} def
/tst false def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% analyze Expression List
%% first last
/AnalyzeListOfE {
  exch SemVector {
    exch 1 index 1 sub AnalyzeExpr 1 add
  } forall%%last_char
  exch AnalyzeExpr
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% analyze Expr
%% first last
/AnalyzeExpr {
  FindFirstAdd%% first last pos+
  2 copy abs 1 sub ne
  { 3 -1 roll 1 index abs 1 sub AnalyzeExpr dup abs 1 add 3 -1 roll  AnalyzeTerm EvalAdd }
  { pop AnalyzeTerm } ifelse 
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% analyze Term
%% first last
/AnalyzeTerm {%%19 28 FLbreak STOP
  FindFirstMul%% first last pos*
  2 copy abs 1 sub ne
  { 3 -1 roll 1 index abs 1 sub AnalyzeTerm dup abs 1 add 3 -1 roll  AnalyzeSignedFactor EvalMul }%%% NEW 2004/11/14
  { pop AnalyzeSignedFactor } ifelse%%% NEW 2004/11/14
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% NEW 2004/11/14
%% analyze Signed Factor
%% first last ->
/AnalyzeSignedFactor {
  ExpressionString 2 index get
  dup 45 eq%% a - sign
  { pop exch 1 add exch AnalyzeSignedFactor EvalNeg }
  { 43 eq%%a + sign
    { exch 1 add exch AnalyzeSignedFactor }
    { AnalyzeFactor } ifelse } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% analyze Factor
%% first last ->
/AnalyzeFactor {
  FindFirstPow%% first last pos*
  2 copy abs 1 sub ne
%  { 3 -1 roll 1 index abs 1 sub AnalyzeFactor dup abs 1 add 3 -1 roll  AnalyzePower EvalPow }
  { 3 -1 roll 1 index abs 1 sub AnalyzeFactor dup abs 1 add 3 -1 roll  AnalyzeSignedFactor EvalPow }% NEW 2004/11/14
  { pop AnalyzePower } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% analyze Power
%% first last ->
/compteur 0 def 
/AnalyzePower {
  ExpressionString 2 index get
  dup 40 eq%% an open parenthesis
  { pop 1 index UnfreePar 1 sub exch 1 add exch AnalyzeExpr }
  {  dup 45 eq%% a - sign
    { pop exch 1 add exch AnalyzePower EvalNeg }
    { dup 43 eq%%a + sign
      { pop exch 1 add exch AnalyzePower }
      { dup 46 eq 1 index 48 ge 2 index 57 le and or%%a digit or a dot
      	{ pop AnalyzeNumber }
      	{ pop AnalyzeLiteral } ifelse } ifelse } ifelse } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% analyze parameters list
%% first last
/AnalyzeParam {
  { FindFirstCom%% first last pos,
    3 -1 roll 1 index 1 sub AnalyzeExpr
    2 copy 1 sub ne { 1 add exch } { pop pop exit } ifelse
  } loop
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Find the eventual addition at this level
%% first last -> position
/FindFirstAdd {
  2 copy /Last exch def /First exch def false 0
  AddVector {
    AddVectorFree 2 index get
    { /pos exch def
      true 0 1 ClParVector length 1 sub
      { ParVectorFree 1 index get
        { OpParVector 1 index get pos abs le
          ClParVector 2 index get pos abs ge and
 	  pos abs First lt pos abs Last gt or or
          { pop pop false exit } if
        } if
        pop
      } for
      { pop pop true dup exit } if
    }
    { pop } ifelse
    1 add
  } forall
  pop
  { pos UnfreeAdd}%% find one add
  { Last 1 add } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Find the eventual multiplication at this level
%% first last -> first last position
/FindFirstMul {
  2 copy /Last exch def /First exch def false 0
  MulVector {
    MulVectorFree 2 index get
    { /pos exch def
      %% if it is in the current part of the analysed expr
      pos abs First gt pos abs Last lt and
      { true 0 1 ClParVector length
        dup 0 eq%% no parenthesis
      	{ pop pop pop pop exch not exch exit }
      	{ 1 sub
      	  { ParVectorFree 1 index get
      	    { OpParVector 1 index get pos abs lt%% in this parenthesis level
      	      ClParVector 2 index get pos abs gt and
      	      { pop pop false exit } if%%then exit loop
      	    } if
      	    pop } for
      	  { pop pop true dup exit } if } ifelse } if
    } { pop } ifelse
    1 add
  } forall
  pop
  { pos UnfreeMul} %% find one mul
  { Last 1 add } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Find the eventual power at this level
%% first last -> first last position
/FindFirstPow {
  2 copy /Last exch def /First exch def false 0
  PowVector {
    PowVectorFree 2 index get
    { /pos exch def
      %% if it is in the current part of the analysed expr
      pos First gt pos Last lt and
      { true 0 1 ClParVector length
      	dup 0 eq%% no parenthesis
      	{ pop pop pop pop exch not exch exit }
      	{ 1 sub
      	  { ParVectorFree 1 index get
      	    { OpParVector 1 index get pos abs lt%% in this parenthesis level
      	      ClParVector 2 index get pos abs gt and
      	      { pop pop false exit } if%%then exit loop
      	    } if
      	    pop } for
      	  { pop pop true dup exit } if } ifelse } if
    } { pop } ifelse
    1 add
  } forall
  pop
  { pos UnfreePow} %% find one ^
  { Last 1 add } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Find the eventual comma at this level
%% first last -> first last position
/FindFirstCom {
  2 copy /Last exch def /First exch def false 0
  ComVector {
    ComVectorFree 2 index get
    { /pos exch def
      %% if it is in the current part of the analysed expr
      pos First gt pos Last lt and
      { true 0 1 ClParVector length
      	dup 0 eq%% no parenthesisSTOP 
      	{ pop pop pop pop exch not exch exit }
      	{ 1 sub
      	  { ParVectorFree 1 index get
      	    { OpParVector 1 index get pos abs lt%% in this parenthesis level
      	      ClParVector 2 index get pos abs gt and
      	      { pop pop false exit } if%%then exit loop
      	    } if
      	    pop } for
      	  { pop pop true dup exit } if } ifelse } if
    } { pop } ifelse
    1 add
  } forall
  pop
  { pos UnfreeCom} %% find one mul
  { Last 1 add } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Find the eventual addition at this level
%% first last -> first last position
/FindFirstPar {
  2 copy /Last exch def /First exch def false 0
  OpParVector {
    ParVectorFree 2 index get
    { /pos exch def
      pos First gt pos Last lt and
      { exch not exch exit } if
    } { pop } ifelse
    1 add
  } forall
  pop
  { pos dup UnfreePar }%% find one mul
  { Last 1 add } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Find the first opening bracket
%% first last -> first last position
/FindFirstBra {
  2 copy /Last exch def /First exch def
  BraVector {
    /pos exch def
    pos First gt pos Last lt and
    { exit } if
  } forall
  pos dup UnfreePar%% finding it is mandatory
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Read the number and push it in the vector
%% first last -> 
/AnalyzeNumber {
  1 index sub 1 add ExpressionString 3 1 roll getinterval cvr /n exch def
  /ExpressionVector ExpressionVector aload length n exch 1 add array astore def
} def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Read the literal and push it in the vector
%% first last -> 
/AnalyzeLiteral {
  ExpressionString 1 index get dup 41 eq%%close par at the end => function call
  { pop FindFirstPar%%first last parpos
    ExpressionString 3 index dup 3 index exch sub getinterval
    dup (SUM) eq 
    { 1 index 1 add 3 index 1 sub FindFirstCom%%
      3 -1 roll 1 index 1 sub AnalyzeExpr  toto }
    { 1 index 1 add 3 index 1 sub AnalyzeParam
      dup cvn /n exch def TrigoFunc
      /ExpressionVector ExpressionVector aload length
      /tx@EqdfDict cvx /begin cvx n cvx /end cvx 5 -1 roll 4 add array astore def
      %%n cvx exch 1 add array astore def
      pop pop pop } ifelse
  }
  { 93 eq%%close bracket => vector element
    { FindFirstBra%%first last brapos
      ExpressionString 3 index dup 3 index exch sub getinterval cvn /n exch def
      /ExpressionVector ExpressionVector aload length n cvx exch 1 add array astore def
      2 copy 1 add exch 1 sub AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def
      pop pop pop
    }
    { 1 index sub 1 add ExpressionString 3 1 roll getinterval cvn /n exch def
     /ExpressionVector ExpressionVector aload length n cvx exch 1 add array astore def } ifelse } ifelse
} def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% push add in the vector
%% kind -> 
%% if kind>0 then add else sub
/EvalAdd {
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll
  0 gt { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% push mul in the vector
%% -> 
/EvalMul {
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll
  0 gt { /mul } { /div } ifelse cvx exch 1 add  array astore def
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% push exp in the vector
%% -> 
/EvalPow {
  pop /ExpressionVector ExpressionVector aload length
  /exp cvx exch 1 add array astore def
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% push neg in the vector
%% -> 
/EvalNeg {
  /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Lexical Analyzis of the string
%% -> 
/LexStr {
  /freepar 0 def /lastpar 0 def /lastchar 0 def
  0 ExpressionString
  { dup 40 eq 1 index 91 eq or %% open parenthesis
    { /OpParVector OpParVector aload length dup 3 add index exch 1 add array astore def 
      /ClParVector ClParVector aload length -1 exch 1 add array astore def
      /lastpar freepar def /freepar freepar 1 add def /NoPar false def} if
    dup 41 eq 1 index 93 eq or %% close parenthesis
    { ClParVector lastpar 3 index put lastpar
      dup 0 eq
      { pop }
      { { 1 sub dup ClParVector exch get -1 eq { /lastpar exch def exit } { dup 0 eq { pop exit} if } ifelse } loop }
      ifelse } if
    dup 42 eq %% * operator
    %%{ /MulVector MulVector aload length dup 3 add index exch 1 add array astore def } if
    { /MulVector 2 index MulVector aload length 1 add array astore def } if
    dup 43 eq %% + operator
    { %%test if it is a real operator and not the unary operator
      lastchar dup  40 ne      %% open parenthesis
           1 index  59 ne and  %% ;
           1 index  42 ne and  %% *
           1 index  43 ne and  %% +
           1 index  44 ne and  %% ,
           1 index  45 ne and  %% -
           1 index  47 ne and  %% /
           1 index   0 ne and  %% first char
           1 index  94 ne and  %% ^%%2004/11/14
              exch 124 ne and  %% |
      %%{/AddVector AddVector aload length dup 3 add index exch 1 add array astore def } if}
      {/AddVector 2 index AddVector aload length 1 add array astore def } if}
    if
    dup 44 eq %% , separator
    { /ComVector ComVector aload length dup 3 add index exch 1 add array astore def }
    if
    dup 45 eq %% - operator
    { %%test if it is a real operator and not the unary operator
      lastchar dup  40 ne      %% open parenthesis
           1 index  59 ne and  %% ;
           1 index  42 ne and  %% *
           1 index  43 ne and  %% +
           1 index  44 ne and  %% ,
           1 index  45 ne and  %% -
           1 index  47 ne and  %% /
           1 index   0 ne and  %% first char
           1 index  94 ne and  %% ^%%2004/11/14
              exch 124 ne and  %% |
      %%{/AddVector AddVector aload length dup 3 add index neg exch 1 add array astore def } if}
      {/AddVector 2 index neg AddVector aload length 1 add array astore def } if}
    if
    dup 47 eq %% / operator
    %%{ /MulVector MulVector aload length dup 3 add index neg exch 1 add array astore def }
    { /MulVector 2 index neg MulVector aload length 1 add array astore def }
    if
    dup 59 eq 1 index 124 eq or%% ; separator |
    { /SemVector SemVector aload length dup 3 add index exch 1 add array astore def }
    if
    dup 91 eq %% open bracket
    { /BraVector BraVector aload length dup 3 add index exch 1 add array astore def }
    if
    dup 94 eq %% ^ operator
    %%{ /PowVector PowVector aload length dup 3 add index exch 1 add array astore def }
    { /PowVector 2 index PowVector aload length 1 add array astore def }%%2004/11/14
    if
    /lastchar exch def 1 add
  } forall
  /AddVectorFree AddVector CreateFree def
  /MulVectorFree MulVector CreateFree def
  /ParVectorFree OpParVector CreateFree def
  /PowVectorFree PowVector CreateFree def
  /ComVectorFree ComVector CreateFree def
  1 sub
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Create Free vector
%% ->
/CreateFree {
  dup length array exch
  { pop true exch } forall astore
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Unfree parenthesis
%% pos ->
/UnfreePar {
  /pos exch def ParVectorFree 0
  OpParVector { pos eq { exit } if 1 add } forall
  false put
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Unfree mul
%% pos ->
/UnfreeMul {
  MulVectorFree 0
  MulVector { pos eq { exit } if 1 add } forall
  false put
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Unfree add
%% pos ->
/UnfreeAdd {
  AddVectorFree 0
  AddVector { pos eq { exit } if 1 add } forall
  false put
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Unfree exp
%% pos ->
/UnfreePow {
  PowVectorFree 0
  PowVector { pos eq { exit } if 1 add } forall
  false put
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Unfree com
%% pos ->
/UnfreeCom {
  ComVectorFree 0
  ComVector { pos eq { exit } if 1 add } forall
  false put
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length 3.14159265359 /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% METHODS FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PI     3.14155265359 def
/PIdiv2 1.57079632680 def
%% Make a discrete sum
%% n begin end expr ->
/SUM {} def
%% function arcsine in radians
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup abs 1 eq
  { PIdiv2 exch -1 eq { neg } if }
  { .1 %% asin(x)
    { dup dup PI div 180 mul sin 3 index sub exch PI div 180 mul cos div
      dup abs 1e-6 lt { sub exit } if sub
    } loop
    exch pop } ifelse
} def
%% function arccosine in radians
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup abs 1 eq
  { -1 eq { PI } { 0 } ifelse }
  { 1.5 %% asin(x)
    { dup dup PI div 180 mul cos 3 index sub exch PI div 180 mul sin neg div
      dup abs 1e-6 lt { sub exit } if sub
    } loop
    exch pop } ifelse
} def
/fact { 1 exch 2 exch 1 exch { mul } for } def
end
% END pst-eqdf.pro

%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]/Metrics
exch def dict begin Encoding{exch dup type/integertype ne{pop pop 1 sub
dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get div def}
ifelse}forall Metrics/Metrics currentdict end def[2 index currentdict
end definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{
dup sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1
roll mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def
dup[exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}
if}forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}
def end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/psfts{S 65781.76 div N}N/startTexFig{/psf$SavedState
save N userdict maxlength dict begin/magscale true def normalscale
currentpoint TR/psf$ury psfts/psf$urx psfts/psf$lly psfts/psf$llx psfts
/psf$y psfts/psf$x psfts currentpoint/psf$cy X/psf$cx X/psf$sx psf$x
psf$urx psf$llx sub div N/psf$sy psf$y psf$ury psf$lly sub div N psf$sx
psf$sy scale psf$cx psf$sx div psf$llx sub psf$cy psf$sy div psf$ury sub
TR/showpage{}N/erasepage{}N/copypage{}N/p 3 def @MacSetUp}N/doclip{
psf$llx psf$lly psf$urx psf$ury currentpoint 6 2 roll newpath 4 copy 4 2
roll moveto 6 -1 roll S lineto S lineto S lineto closepath clip newpath
moveto}N/endTexFig{end psf$SavedState restore}N/@beginspecial{SDict
begin/SpecialSave save N gsave normalscale currentpoint TR
@SpecialDefaults count/ocount X/dcount countdictstack N}N/@setspecial{
CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto 0 vs rlineto hs neg 0 rlineto
closepath clip}if ho vo TR hsc vsc scale ang rotate rwiSeen{rwi urx llx
sub div rhiSeen{rhi ury lly sub div}{dup}ifelse scale llx neg lly neg TR
}{rhiSeen{rhi ury lly sub div dup scale llx neg lly neg TR}if}ifelse
CLIP 2 eq{newpath llx lly moveto urx lly lineto urx ury lineto llx ury
lineto closepath clip}if/showpage{}N/erasepage{}N/copypage{}N newpath}N
/@endspecial{count ocount sub{pop}repeat countdictstack dcount sub{end}
repeat grestore SpecialSave restore end}N/@defspecial{SDict begin}N
/@fedspecial{end}B/li{lineto}B/rl{rlineto}B/rc{rcurveto}B/np{/SaveX
currentpoint/SaveY X N 1 setlinecap newpath}N/st{stroke SaveX SaveY
moveto}N/fil{fill SaveX SaveY moveto}N/ellipse{/endangle X/startangle X
/yrad X/xrad X/savematrix matrix currentmatrix N TR xrad yrad scale 0 0
1 startangle endangle arc savematrix setmatrix}N end

%%EndProcSet
%%BeginFont: CMSY7
%!PS-AdobeFont-1.1: CMSY7 1.0
%%CreationDate: 1991 Aug 15 07:21:52
% Copyright (C) 1997 American Mathematical Society. All Rights Reserved.
11 dict begin
/FontInfo 7 dict dup begin
/version (1.0) readonly def
/Notice (Copyright (C) 1997 American Mathematical Society. All Rights Reserved) readonly def
/FullName (CMSY7) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle -14.035 def
/isFixedPitch false def
end readonly def
/FontName /CMSY7 def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 48 /prime put
readonly def
/FontBBox{-15 -951 1252 782}readonly def
/UniqueID 5000817 def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA052F09F9C8ADE9D907C058B87E9B6964
7D53359E51216774A4EAA1E2B58EC3176BD1184A633B951372B4198D4E8C5EF4
A213ACB58AA0A658908035BF2ED8531779838A960DFE2B27EA49C37156989C85
E21B3ABF72E39A89232CD9F4237FC80C9E64E8425AA3BEF7DED60B122A52922A
221A37D9A807DD01161779DDE7D251491EBF65A98C9FE2B1CF8D725A70281949
8F4AFFE638BBA6B12386C7F32BA350D62EA218D5B24EE612C2C20F43CD3BFD0D
F02B185B692D7B27BEC7290EEFDCF92F95DDEB507068DE0B0B0351E3ECB8E443
E611BE0A41A1F8C89C3BC16B352C3443AB6F665EAC5E0CC4229DECFC58E15765
424C919C273E7FA240BE7B2E951AB789D127625BBCB7033E005050EB2E12B1C8
E5F3AD1F44A71957AD2CC53D917BFD09235601155886EE36D0C3DD6E7AA2EF9C
C402C77FF1549E609A711FC3C211E64E8F263D60A57E9F2B47E3480B978AAF63
868AEA25DA3D5413467B76D2F02F8097D2841EDA6677731A6ACFEC0BABF1016A
089B2D24E941E5E7649642B5280D22A2A1499CA9708C88490B456D647364C957
D289912A4360E31002BEB15135CC9FEBE452F9F6C627968ABD65EC4D987AC218
E4C5427189CFB260E8321817639C61C05B19DD9035A4CDB46FCC415633BB924E
C508609EF6EA51685FD6E4EB10FB915414DBB3022D3733CBEB1BAFD628ACB64A
661042A600224B084B612B557596A01D1F1F5CB77E3E63E93510A79E0D131271
3F35F8C34F36C30A593689DD275BDB0054C56527EE372B33BB5673041EE004DA
002AD9C278B0CBA7F111CF641C05FC33AD07591C6FE59CA12B0E2D
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: CMMI10
%!PS-AdobeFont-1.1: CMMI10 1.100
%%CreationDate: 1996 Jul 23 07:53:57
% Copyright (C) 1997 American Mathematical Society. All Rights Reserved.
11 dict begin
/FontInfo 7 dict dup begin
/version (1.100) readonly def
/Notice (Copyright (C) 1997 American Mathematical Society. All Rights Reserved) readonly def
/FullName (CMMI10) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle -14.04 def
/isFixedPitch false def
end readonly def
/FontName /CMMI10 def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 18 /theta put
dup 76 /L put
dup 79 /O put
dup 80 /P put
dup 81 /Q put
dup 100 /d put
dup 120 /x put
readonly def
/FontBBox{-32 -250 1048 750}readonly def
/UniqueID 5087385 def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA0529731C99A784CCBE85B4993B2EEBDE
3B12D472B7CF54651EF21185116A69AB1096ED4BAD2F646635E019B6417CC77B
532F85D811C70D1429A19A5307EF63EB5C5E02C89FC6C20F6D9D89E7D91FE470
B72BEFDA23F5DF76BE05AF4CE93137A219ED8A04A9D7D6FDF37E6B7FCDE0D90B
986423E5960A5D9FBB4C956556E8DF90CBFAEC476FA36FD9A5C8175C9AF513FE
D919C2DDD26BDC0D99398B9F4D03D5993DFC0930297866E1CD0A319B6B1FD958
9E394A533A081C36D456A09920001A3D2199583EB9B84B4DEE08E3D12939E321
990CD249827D9648574955F61BAAA11263A91B6C3D47A5190165B0C25ABF6D3E
6EC187E4B05182126BB0D0323D943170B795255260F9FD25F2248D04F45DFBFB
DEF7FF8B19BFEF637B210018AE02572B389B3F76282BEB29CC301905D388C721
59616893E774413F48DE0B408BC66DCE3FE17CB9F84D205839D58014D6A88823
D9320AE93AF96D97A02C4D5A2BB2B8C7925C4578003959C46E3CE1A2F0EAC4BF
8B9B325E46435BDE60BC54D72BC8ACB5C0A34413AC87045DC7B84646A324B808
6FD8E34217213E131C3B1510415CE45420688ED9C1D27890EC68BD7C1235FAF9
1DAB3A369DD2FC3BE5CF9655C7B7EDA7361D7E05E5831B6B8E2EEC542A7B38EE
03BE4BAC6079D038ACB3C7C916279764547C2D51976BABA94BA9866D79F13909
95AA39B0F03103A07CBDF441B8C5669F729020AF284B7FF52A29C6255FCAACF1
74109050FBA2602E72593FBCBFC26E726EE4AEF97B7632BC4F5F353B5C67FED2
3EA752A4A57B8F7FEFF1D7341D895F0A3A0BE1D8E3391970457A967EFF84F6D8
47750B1145B8CC5BD96EE7AA99DDC9E06939E383BDA41175233D58AD263EBF19
AFC0E2F840512D321166547B306C592B8A01E1FA2564B9A26DAC14256414E4C8
42616728D918C74D13C349F4186EC7B9708B86467425A6FDB3A396562F7EE4D8
40B43621744CF8A23A6E532649B66C2A0002DD04F8F39618E4F572819DD34837
B5A08E643FDCA1505AF6A1FA3DDFD1FA758013CAED8ACDDBBB334D664DFF5B53
956017667C419C4021DA92976C7550A196C257FC2124E231B1ACAB1D05366C48
5D3997637F9F8EACEFE760F1AD5C1832F78D3D500F37790ADD9DCE82809819D5
9F01DBA7AF9C92C8753B1FC528D933349D6997EE2064BB83D55AE4B434107DDB
9070660E7DB1C75354F6AE76C7B55D4864DBC6C767844ECFE36FE0775A61CCA0
0A20A5E50481BD1DB2F152575BEFF871AA54FE72730EF8EAFFF4DF4C9F51397C
AAB8D1B35520A5153B5ED8D8767520DD7A27D153B797A9B604DD6AECFE6CDFEC
19CC0BE5A3929723F45FEB7F276A042C2B53F5335CF95CC5817B319D91542440
F5AC73E86E1E8DDA50FB2DCE81052C7A2694A0F163EEC048266902A9C26F81FB
09DF79006E32DC47E1DEAA8FFFCF99F45E4805E3D7672BBADCE56C2788E68004
47191D2A0C92F2DFBF26C9EDD64E7020D00D042DA98E13529125538FA9304457
4F3D6EB3667B462A201A1EF06162CF2F42D5EEF61ABB5D2D8D1047A9CFD19CC4
32432B219F1872B5E23AC902217CCBBA8D326A26FBC52486C5AFB717CCA9239F
102007E4FDA8EF76B477D5ABE1A24ADE0A495F65B1926872878A0BAE2A28A3F1
657F42DBD5F49763086111FF71AD406D976017E419A9EE4B3DED6EC01AEE04D9
D64A3A1CC26EA801D7324EDDE2C2E3FCFC2CC9C4C18994628FD6AB565D0B8FEF
EFF9EE820F694D2487E11747D673FEEE7CD725AE5C7497A523E04E318CE648DB
1DEC818D8EB994DBE059EE3EDA20E2B6DE2155BC9193C6F382F6C72E0C8C74C4
FE5EE7C979211D4B64173806551C82F582B15392119105D2DD08FB88B063F0D9
358AF68FE884E6AE2DFD61D17652FDC20A5E1C7FC4827796D103C1AFD92E62E5
BE62BD25DAB63A4B84CC01EF370B7B83AC032EC49C241DF09550609EE40B44F4
BEF26A33ACFBB3B3FC8B9057C6A19BE603C5F46BFD47B00BDD52C047101F3C85
23470B718DEB9EFDEEDCCA5A82C2D160B1889425C285AF2DA83ECEEA7A57B4D4
277127DB73134D30B5A8FF38AAAE0056D9A178C34BE435701272387EE1B3BFEB
916A7877DBF0DEF537F6B3B128C19F8367E0570862A998EF72542EA08FA930FC
E4802E18F3B02CD65BE6F9BA34C2BCDBA59CE50927658BDF620F37482CE19AF3
538F18C74AC7311CB2E5403CFF577695BEB8638D751CD68FBFBF8BF6EB63C795
728806620DBDF901880E6A22BC94E8FE59853F6E77FF0B5C21CA0B2FC134B1A5
F576FEE4F619F30AEE09D24125737F9E11106C9A93C418F0488322EC0E48F78A
4E438514CFFED8D377D9F2019F3ED0DA165507A35A364B7BBDF513FB6F8D1F32
7FFEBCA511F1118084A4B97841FA5ED0905DB7708A7D92D9347ED22CF9A42A40
F83AFD2441B3D0F7C2CA4A8FF20D44F81FDC1E208812F9416A806733C2FB5EB8
D3CBC2146C3F2239BDB305428878B188C5ABEB15C5F347159D77E943038438A1
4D4CB6C42C3744CA5C7EAAE2BE2E0BABBB8AE3F35508AB27A5BE70B9307B4A9A
FEF9C9FF61B7348E02B7022CB7125ED98E36C0AB73A99F45887CB9042BBED50D
2C8585672916CEA712F8B3F95192B97A9C7D85BEC866A12FF98E5D9DC0A8D795
3DBD1172B92A162EE5945F8EF5A0FAE0567083DA47D33086A0AA1BADCCD0D985
75534D4962A697F0B0318A462E451D445CE9DA99E8840C1477B086573217297F
92DCF3EC8AF2AE58C15FBA8B3BDB01E6917136F4383468F8624F59A893DBD739
DB9C98A76CBEF2005B5AF1678439DFEA5A6955489362AAC23461D86A641A73B2
CA1FD7CB2311D0CA9E88B3614AE90E4DFFB4077B120A9AD583609939F88A2F42
7C9432A633EE42F563F952401880DFD78E90AE15DB3629C1C43E96075AFD04A9
F815C6B6A2B67CE7D128A1E9EEA37A7FE72EA5AB0D7D9303DE739E34995030A1
B12AAE9E7756A2DEA4278878A4EBB55C04E3D1D6D294F670E58CFA3DE8026AD9
DE21A67817E563B691E25C7209930373D18BE8530D5C8461488F874D23F69CE5
358EBC3C06427C382AFD186DCD07B28398E1566EDC15C73E1B597BB5EF10BF56
3D153BEF05F32CBBB8EFF9AD713CEADFC60355FD1FD1BE424C10AFFAEB716F86
95330DDCF30CCE6CA3772A569BE03B2F4F5A2A70FE094E7F8802F74AF18F2DE7
8CBE660B3C
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
TeXDict begin 40258437 52099154 1000 600 600 (quanxishu6.dvi)
@start /Fa 207[19 48[{}1 58.1154 /CMSY7 rf /Fb 135[47
19[43 18[66 53 63 2[57 57[39 18[{}7 83.022 /CMMI10 rf
end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
 end
%%EndSetup
TeXDict begin 1 0 bop 166 83 a
 tx@Dict begin tx@NodeDict begin {60.00006 0.0 } false /N@O 10 {InitPnode
} NewNode end end
 166 83 a 166 83 a
 tx@Dict begin tx@NodeDict begin {120.00012 0.0 } false /N@O' 10 {InitPnode
} NewNode end end
 166
83 a 166 83 a
 tx@Dict begin tx@NodeDict begin {60.00006 22.50002 } false /N@P 10
{InitPnode } NewNode end end
 166 83 a 166 83 a
 tx@Dict begin tx@NodeDict begin {120.00012 22.50002 } false /N@P'
10 {InitPnode } NewNode end end
 166 83 a 166 83 a
 tx@Dict begin tx@NodeDict begin {120.00012 -22.50002 } false /N@P''
10 {InitPnode } NewNode end end
 166
83 a @beginspecial @setspecial
 tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def /ArrowInside
{ } def  0.8 SLW 0. setgray  /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  [ 60.00006 -30.00003 60.00006 30.00003  /Lineto
/lineto load def false NArray n 0 eq not { n 1 eq { 0 0 /n 2 def }
if () length 0 gt { 2 copy /y1 ED /x1 ED ArrowA x1 y1 /n n 1 sub def
n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2
y1 sub x2 x1 sub atan def /ArrowPos 0.  def /Length x2 x1 sub y2 y1
sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos dArrowPos
add def ArrowPos Length gt { exit } if x1 Alpha cos ArrowPos mul add
y1 Alpha sin ArrowPos mul add ArrowInside pop pop } loop }{ /ArrowPos
0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.
 cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul
x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat }
ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto
} repeat } ifelse CP 4 2 roll ArrowB L pop pop } if  gsave 0.8 SLW
0. setgray 0 setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
 tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def /ArrowInside
{ } def  0.8 SLW 0. setgray  /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  [ 120.00012 -30.00003 120.00012 30.00003  /Lineto
/lineto load def false NArray n 0 eq not { n 1 eq { 0 0 /n 2 def }
if () length 0 gt { 2 copy /y1 ED /x1 ED ArrowA x1 y1 /n n 1 sub def
n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2
y1 sub x2 x1 sub atan def /ArrowPos 0.  def /Length x2 x1 sub y2 y1
sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos dArrowPos
add def ArrowPos Length gt { exit } if x1 Alpha cos ArrowPos mul add
y1 Alpha sin ArrowPos mul add ArrowInside pop pop } loop }{ /ArrowPos
0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.
 cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul
x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat }
ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto
} repeat } ifelse CP 4 2 roll ArrowB L pop pop } if  gsave 0.8 SLW
0. setgray 0 setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
 tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def /ArrowInside
{ BeginArrow 1.  1.  scale false 0.4 1.4 4.50005 0. CLW mul add dup
2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w
neg h moveto 0 0 L w h L w neg a neg rlineto gsave fill grestore grestore
0 h a sub moveto   EndArrow  } def  0.4 SLW 0. setgray  /ArrowA { moveto
} def /ArrowB { } def /ArrowInside { BeginArrow 1.  1.  scale false
0.4 1.4 4.50005 0. CLW mul add dup 2 div /w ED mul dup /h ED mul /a
ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a
neg rlineto gsave fill grestore grestore 0 h a sub moveto   EndArrow
 } def  [ tx@NodeDict begin tx@NodeDict /N@O known { /N@O load GetCenter
} { 0 0 } ifelse end 0.0 0.0  /Lineto /lineto load def false NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if (>) length 0 gt { 2 copy /y1
ED /x1 ED ArrowA x1 y1 /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2
ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub atan def /ArrowPos
0.  def /Length x2 x1 sub y2 y1 sub Pyth def /dArrowPos 0.5  abs def
{ /ArrowPos ArrowPos dArrowPos add def ArrowPos Length gt { exit }
if x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside
pop pop } loop }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0
add div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add
def x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if  gsave 0.4 SLW 0. setgray 0 setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
 tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def /ArrowInside
{ BeginArrow 1.  1.  scale false 0.4 1.4 4.50005 0. CLW mul add dup
2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w
neg h moveto 0 0 L w h L w neg a neg rlineto gsave fill grestore grestore
0 h a sub moveto   EndArrow  } def  0.4 SLW 0. setgray  /ArrowA { moveto
} def /ArrowB { } def /ArrowInside { BeginArrow 1.  1.  scale false
0.4 1.4 4.50005 0. CLW mul add dup 2 div /w ED mul dup /h ED mul /a
ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a
neg rlineto gsave fill grestore grestore 0 h a sub moveto   EndArrow
 } def  [ tx@NodeDict begin tx@NodeDict /N@P known { /N@P load GetCenter
} { 0 0 } ifelse end 0.0 22.50002  /Lineto /lineto load def false NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if (>) length 0 gt { 2 copy /y1
ED /x1 ED ArrowA x1 y1 /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2
ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub atan def /ArrowPos
0.  def /Length x2 x1 sub y2 y1 sub Pyth def /dArrowPos 0.5  abs def
{ /ArrowPos ArrowPos dArrowPos add def ArrowPos Length gt { exit }
if x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside
pop pop } loop }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0
add div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add
def x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if  gsave 0.4 SLW 0. setgray 0 setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
 tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def /ArrowInside
{ BeginArrow 1.  1.  scale false 0.4 1.4 4.50005 0. CLW mul add dup
2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w
neg h moveto 0 0 L w h L w neg a neg rlineto gsave fill grestore grestore
0 h a sub moveto   EndArrow  } def  0.4 SLW 0. setgray  /ArrowA { moveto
} def /ArrowB { } def /ArrowInside { BeginArrow 1.  1.  scale false
0.4 1.4 4.50005 0. CLW mul add dup 2 div /w ED mul dup /h ED mul /a
ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a
neg rlineto gsave fill grestore grestore 0 h a sub moveto   EndArrow
 } def  [ tx@NodeDict begin tx@NodeDict /N@P' known { /N@P' load GetCenter
} { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@P known { /N@P
load GetCenter } { 0 0 } ifelse end  /Lineto /lineto load def false
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if (>) length 0 gt { 2
copy /y1 ED /x1 ED ArrowA x1 y1 /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub atan
def /ArrowPos 0.  def /Length x2 x1 sub y2 y1 sub Pyth def /dArrowPos
0.5  abs def { /ArrowPos ArrowPos dArrowPos add def ArrowPos Length
gt { exit } if x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } loop }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if  gsave 0.4 SLW 0. setgray 0 setlinecap
stroke  grestore end
 
@endspecial @beginspecial @setspecial
 tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def /ArrowInside
{ BeginArrow 1.  1.  scale false 0.4 1.4 4.50005 0. CLW mul add dup
2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w
neg h moveto 0 0 L w h L w neg a neg rlineto gsave fill grestore grestore
0 h a sub moveto   EndArrow  } def  0.4 SLW 0. setgray  /ArrowA { moveto
} def /ArrowB { } def /ArrowInside { BeginArrow 1.  1.  scale false
0.4 1.4 4.50005 0. CLW mul add dup 2 div /w ED mul dup /h ED mul /a
ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a
neg rlineto gsave fill grestore grestore 0 h a sub moveto   EndArrow
 } def  [ tx@NodeDict begin tx@NodeDict /N@P' known { /N@P' load GetCenter
} { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@O known { /N@O
load GetCenter } { 0 0 } ifelse end  /Lineto /lineto load def false
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if (>) length 0 gt { 2
copy /y1 ED /x1 ED ArrowA x1 y1 /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub atan
def /ArrowPos 0.  def /Length x2 x1 sub y2 y1 sub Pyth def /dArrowPos
0.5  abs def { /ArrowPos ArrowPos dArrowPos add def ArrowPos Length
gt { exit } if x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } loop }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if  gsave 0.4 SLW 0. setgray 0 setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
 tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def /ArrowInside
{ BeginArrow 1.  1.  scale false 0.4 1.4 4.50005 0. CLW mul add dup
2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w
neg h moveto 0 0 L w h L w neg a neg rlineto gsave fill grestore grestore
0 h a sub moveto   EndArrow  } def  0.4 SLW 0. setgray  /ArrowA { moveto
} def /ArrowB { } def /ArrowInside { BeginArrow 1.  1.  scale false
0.4 1.4 4.50005 0. CLW mul add dup 2 div /w ED mul dup /h ED mul /a
ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a
neg rlineto gsave fill grestore grestore 0 h a sub moveto   EndArrow
 } def  [ tx@NodeDict begin tx@NodeDict /N@P'' known { /N@P'' load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@O known
{ /N@O load GetCenter } { 0 0 } ifelse end  /Lineto /lineto load def
false NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if (>) length 0 gt
{ 2 copy /y1 ED /x1 ED ArrowA x1 y1 /n n 1 sub def n { 4 copy /y1 ED
/x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub atan
def /ArrowPos 0.  def /Length x2 x1 sub y2 y1 sub Pyth def /dArrowPos
0.5  abs def { /ArrowPos ArrowPos dArrowPos add def ArrowPos Length
gt { exit } if x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } loop }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if  gsave 0.4 SLW 0. setgray 0 setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
 tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def /ArrowInside
{ } def  0.4 SLW 0. setgray  /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  [ tx@NodeDict begin tx@NodeDict /N@O' known {
/N@O' load GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict
/N@O known { /N@O load GetCenter } { 0 0 } ifelse end  /Lineto /lineto
load def false NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length
0 gt { 2 copy /y1 ED /x1 ED ArrowA x1 y1 /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub atan def /ArrowPos 0.  def /Length x2 x1 sub y2 y1 sub Pyth def
/dArrowPos 0.5  abs def { /ArrowPos ArrowPos dArrowPos add def ArrowPos
Length gt { exit } if x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } loop }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if  gsave 0.4 SLW 0. setgray 0 setlinecap
stroke  grestore end
 
@endspecial 166 83 a
 tx@Dict begin tx@NodeDict begin {tx@NodeDict begin tx@NodeDict /N@O
known { /N@O load GetCenter } { 0 0 } ifelse end /YA exch 15.00002
div def /XA exch 15.00002 div def tx@NodeDict begin tx@NodeDict /N@O'
known { /N@O' load GetCenter } { 0 0 } ifelse end /YB exch 15.00002
div def /XB exch 15.00002 div def /dx XB XA sub def /dy YB YA sub def
XA dx 0.6 mul add YA dy 0.6 mul add 15.00002 mul exch 15.00002 mul
exch } false /N@@temp@lnput 10 {InitPnode } NewNode end end
 166 83 a 166 83 a
 tx@Dict begin tx@NodeDict begin {tx@NodeDict begin tx@NodeDict /N@O
known { /N@O load GetCenter } { 0 0 } ifelse end } false /N@@@A 10
{InitPnode } NewNode end end
 166
83 a 166 83 a
 tx@Dict begin tx@NodeDict begin {tx@NodeDict begin tx@NodeDict /N@@temp@lnput
known { /N@@temp@lnput load GetCenter } { 0 0 } ifelse end } false
/N@@@B 10 {InitPnode } NewNode end end
 166 83 a 166 83 a
 tx@Dict begin gsave STV newpath 0.4 SLW 0. setgray  /ArrowA { moveto
} def /ArrowB { } def /ArrowInside { } def  0.4 SLW 0. setgray  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def  /NCLW CLW def
tx@NodeDict begin -4.30554 -4.30554 neg 0.0 0.0 0 0 /N@@@A /N@@@B InitNC
{ NCCoor tx@Dict begin ArrowA CP 4 2 roll ArrowB 4 copy /y2 ED /x2
ED /y1 ED /x1 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub atan
def /ArrowPos 0.  def /Length x2 x1 sub y2 y1 sub Pyth def /dArrowPos
0.5  abs def {/ArrowPos ArrowPos dArrowPos add def ArrowPos Length
gt { exit } if x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } loop }{/ArrowPos 0.  def /dArrowPos 1.
1 gt {1.0 1. 1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos
mul y1 add ArrowInside pop pop } repeat } ifelse pop pop lineto pop
pop end  } if end  grestore end
 166 83 a 166 83 a
 tx@Dict begin tx@NodeDict begin /t 1. def LPut end PutBegin  end
 166
83 a 138 111 a Fb(L)166 83 y
 tx@Dict begin PutEnd  end
 166 83 a @beginspecial @setspecial
 tx@Dict begin STP newpath end


@endspecial 166 83 a
 tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@O known { /N@O load
GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 166 83 a 166 83 a
 tx@Dict begin { 2.15277 7.90555 6.83331 0.0 -135.  Uput UUput } PutCoor
PutBegin  end
 166 83 a 133
111 a Fb(O)166 83 y
 tx@Dict begin PutEnd  end
 166 83 a 166 83 a
 tx@Dict begin PutEnd  end
 166 83 a 166 83
a
 tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@P known { /N@P load
GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 166 83 a 166 83 a
 tx@Dict begin { 2.15277 7.80904 6.83331 0.0 -135.  Uput UUput } PutCoor
PutBegin  end
 166 83 a 134 111 a Fb(P)166 83 y
 tx@Dict begin PutEnd  end

166 83 a 166 83 a
 tx@Dict begin PutEnd  end
 166 83 a 166 83 a
 tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@O' known { /N@O'
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 166 83 a 166 83 a
 tx@Dict begin { 2.15277 10.7111 7.51782 0.0 -135.  Uput UUput } PutCoor
PutBegin  end

166 83 a 122 114 a Fb(O)187 84 y Fa(0)166 83 y
 tx@Dict begin PutEnd  end
 166 83
a 166 83 a
 tx@Dict begin PutEnd  end
 166 83 a 166 83 a
 tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@P' known { /N@P'
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 166 83 a 166 83 a
 tx@Dict begin { 2.15277 10.6146 7.51782 0.0 45.  Uput UUput } PutCoor
PutBegin  end
 166 83
a 122 114 a Fb(P)187 84 y Fa(0)166 83 y
 tx@Dict begin PutEnd  end
 166 83 a 166
83 a
 tx@Dict begin PutEnd  end
 166 83 a 166 83 a
 tx@Dict begin tx@NodeDict begin {tx@NodeDict begin tx@NodeDict /N@O
known { /N@O load GetCenter } { 0 0 } ifelse end } false /N@@@A 10
{InitPnode } NewNode end end
 166 83 a 166 83 a
 tx@Dict begin tx@NodeDict begin {tx@NodeDict begin tx@NodeDict /N@P
known { /N@P load GetCenter } { 0 0 } ifelse end } false /N@@@B 10
{InitPnode } NewNode end end
 166 83 a 166
83 a
 tx@Dict begin gsave STV newpath /ArrowA { BeginArrow 1.  1.  scale
false 0.4 1.4 2.99995 0. CLW mul add dup 2 div /w ED mul dup /h ED
mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L
w neg a neg rlineto gsave fill grestore grestore 0 h a sub moveto 
 EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale false 0.4
1.4 2.99995 0. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED
{ 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg
rlineto gsave fill grestore grestore 0 h a sub moveto   EndArrow  }
def /ArrowInside { } def  0.4 SLW 0. setgray  /ArrowA { BeginArrow
1.  1.  scale false 0.4 1.4 2.99995 0. CLW mul add dup 2 div /w ED
mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto
0 0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a
sub moveto   EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale
false 0.4 1.4 2.99995 0. CLW mul add dup 2 div /w ED mul dup /h ED
mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L
w neg a neg rlineto gsave fill grestore grestore 0 h a sub moveto 
 EndArrow  } def /ArrowInside { } def  /NCLW CLW def tx@NodeDict begin
15.00002 15.00002 neg 0.0 0.0 0 0 /N@@@A /N@@@B InitNC { NCCoor tx@Dict
begin ArrowA CP 4 2 roll ArrowB 4 copy /y2 ED /x2 ED /y1 ED /x1 ED
x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub atan def /ArrowPos 0.
 def /Length x2 x1 sub y2 y1 sub Pyth def /dArrowPos 0.5  abs def {/ArrowPos
ArrowPos dArrowPos add def ArrowPos Length gt { exit } if x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } loop }{/ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div
}{ 0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop lineto pop pop end  } if end gsave
0.4 SLW 0. setgray 0 setlinecap stroke  grestore  grestore end
 166 83 a 166 83 a
 tx@Dict begin tx@NodeDict begin /t .5 def LPut end PutBegin  end
 166 83 a 144 112 a @beginspecial
@setspecial
 tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def /ArrowInside
{ } def  0.0 SLW 1. setgray  0. true 1.0 neg 1.0 neg 6.20486 7.94444
.5 Frame  gsave 1. setgray fill grestore end
 
@endspecial Fb(d)166 83 y
 tx@Dict begin PutEnd  end
 166 83 a 166 83
a
 tx@Dict begin tx@NodeDict begin {tx@NodeDict begin tx@NodeDict /N@P'
known { /N@P' load GetCenter } { 0 0 } ifelse end } false /N@@@A 10
{InitPnode } NewNode end end
 166 83 a 166 83 a
 tx@Dict begin tx@NodeDict begin {tx@NodeDict begin tx@NodeDict /N@P''
known { /N@P'' load GetCenter } { 0 0 } ifelse end } false /N@@@B 10
{InitPnode } NewNode end end
 166 83 a 166 83 a
 tx@Dict begin gsave STV newpath /ArrowA { BeginArrow 1.  1.  scale
2.0 5. Tbar 0 CLW 2 div T newpath false 0.4 1.4 2.99995 0. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave fill grestore
grestore 0 h a sub moveto   EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 2.0 5. Tbar 0 CLW 2 div T newpath false 0.4 1.4 2.99995
0. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1
scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave
fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  0.4 SLW 0. setgray  /ArrowA { BeginArrow 1.  1.  scale 2.0
5. Tbar 0 CLW 2 div T newpath false 0.4 1.4 2.99995 0. CLW mul add
dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave
w neg h moveto 0 0 L w h L w neg a neg rlineto gsave fill grestore
grestore 0 h a sub moveto   EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 2.0 5. Tbar 0 CLW 2 div T newpath false 0.4 1.4 2.99995
0. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1
scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave
fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  /NCLW CLW def tx@NodeDict begin 6.45831 6.45831 neg 0.0 0.0
0 0 /N@@@A /N@@@B InitNC { NCCoor tx@Dict begin ArrowA CP 4 2 roll
ArrowB 4 copy /y2 ED /x2 ED /y1 ED /x1 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub atan def /ArrowPos 0.  def /Length x2 x1 sub y2
y1 sub Pyth def /dArrowPos 0.5  abs def {/ArrowPos ArrowPos dArrowPos
add def ArrowPos Length gt { exit } if x1 Alpha cos ArrowPos mul add
y1 Alpha sin ArrowPos mul add ArrowInside pop pop } loop }{/ArrowPos
0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{ 0.5 } ifelse def
1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul
x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat }
ifelse pop pop lineto pop pop end  } if end gsave 0.4 SLW 0. setgray
0 setlinecap stroke  grestore  grestore end
 166 83 a 166 83
a
 tx@Dict begin tx@NodeDict begin /t .5 def LPut end PutBegin  end
 166 83 a 142 101 a @beginspecial @setspecial
 tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def /ArrowInside
{ } def  0.0 SLW 1. setgray  0. true 1.0 neg 1.0 neg 6.71527 5.30554
.5 Frame  gsave 1. setgray fill grestore end
 
@endspecial
Fb(x)166 83 y
 tx@Dict begin PutEnd  end
 166 83 a 166 83 a
 tx@Dict begin tx@NodeDict begin {tx@NodeDict begin tx@NodeDict /N@P''
known { /N@P'' load GetCenter } { 0 0 } ifelse end /YA exch 15.00002
div def /XA exch 15.00002 div def tx@NodeDict begin tx@NodeDict /N@O
known { /N@O load GetCenter } { 0 0 } ifelse end /YB exch 15.00002
div def /XB exch 15.00002 div def XA 1 mul XB -1 mul add YA 1 mul YB
-1 mul add 15.00002 mul exch 15.00002 mul exch } false /N@@temp@OA
10 {InitPnode } NewNode end end
 166 83 a 166 83 a
 tx@Dict begin tx@NodeDict begin {tx@NodeDict begin tx@NodeDict /N@P'
known { /N@P' load GetCenter } { 0 0 } ifelse end /YA exch 15.00002
div def /XA exch 15.00002 div def tx@NodeDict begin tx@NodeDict /N@O
known { /N@O load GetCenter } { 0 0 } ifelse end /YB exch 15.00002
div def /XB exch 15.00002 div def XA 1 mul XB -1 mul add YA 1 mul YB
-1 mul add 15.00002 mul exch 15.00002 mul exch } false /N@@temp@OB
10 {InitPnode } NewNode end end
 166
83 a @beginspecial @setspecial
 tx@Dict begin STP newpath 0.4 SLW 0. setgray  /ArrowA { /ArrowAc [
6 2 roll ] cvx def ArrowAc BeginArrow 1.  1.  scale false 0.4 1.4 2.99995
0. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1
scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave
fill grestore grestore 0 h a sub moveto   EndArrow  moveto } def /ArrowB
{ /ArrowBc [ 6 2 roll ] cvx def ArrowBc BeginArrow 1.  1.  scale false
0.4 1.4 2.99995 0. CLW mul add dup 2 div /w ED mul dup /h ED mul /a
ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a
neg rlineto gsave fill grestore grestore 0 h a sub moveto   EndArrow
 } def /ArrowInside { } def  0.4 SLW 0. setgray  /ArrowA { /ArrowAc
[ 6 2 roll ] cvx def ArrowAc BeginArrow 1.  1.  scale false 0.4 1.4
2.99995 0. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  moveto }
def /ArrowB { /ArrowBc [ 6 2 roll ] cvx def ArrowBc BeginArrow 1. 
1.  scale false 0.4 1.4 2.99995 0. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  tx@NodeDict begin tx@NodeDict
/N@O known { /N@O load GetCenter } { 0 0 } ifelse end /y ED /x ED /r
15.00002 def /c 57.2957 r Div def /angleA tx@NodeDict begin tx@NodeDict
/N@@temp@OA known { /N@@temp@OA load GetCenter } { 0 0 } ifelse end
exch Atan 0.0 c mul 2 div add def /angleB tx@NodeDict begin tx@NodeDict
/N@@temp@OB known { /N@@temp@OB load GetCenter } { 0 0 } ifelse end
exch Atan 0.0 c mul 2 div sub def x y r angleA { ArrowA CP } { add
} ArcArrow angleB { ArrowB } { sub } ArcArrow arc  gsave 1.0 2 mul
CLW add SLW 1. setgray stroke grestore gsave 0.4 SLW 0. setgray 0 setlinecap
stroke  grestore gsave ArrowAc ArrowA pop pop ArrowBc ArrowB pop pop
pop pop grestore end
 
@endspecial @beginspecial
@setspecial
 tx@Dict begin STP newpath end
 
@endspecial 166 83 a
 tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@O known { /N@O load
GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 166 83 a 166 83 a
 tx@Dict begin { 17.24992 4.97223 6.94444 0.0 0.  Uput UUput } PutCoor
PutBegin  end
 166
83 a 145 112 a @beginspecial @setspecial
 tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def /ArrowInside
{ } def  0.0 SLW 1. setgray  0. true 1.0 neg 1.0 neg 5.97223 7.94444
.5 Frame  gsave 1. setgray fill grestore end
 
@endspecial
Fb(\022)166 83 y
 tx@Dict begin PutEnd  end
 166 83 a 166 83 a
 tx@Dict begin PutEnd  end
 166 83 a 166 83 a
 tx@Dict begin tx@NodeDict begin {tx@NodeDict begin tx@NodeDict /N@P
known { /N@P load GetCenter } { 0 0 } ifelse end /YA exch 15.00002
div def /XA exch 15.00002 div def tx@NodeDict begin tx@NodeDict /N@O
known { /N@O load GetCenter } { 0 0 } ifelse end /YB exch 15.00002
div def /XB exch 15.00002 div def tx@NodeDict begin tx@NodeDict /N@P'
known { /N@P' load GetCenter } { 0 0 } ifelse end /YC exch 15.00002
div def /XC exch 15.00002 div def /getk XA XB sub XC XB sub mul YA
YB sub YC YB sub mul add XC XB sub dup mul YC YB sub dup mul add div
def XC XB sub getk mul XB add YC YB sub getk mul YB add 15.00002 mul
exch 15.00002 mul exch } false /N@Q 10 {InitPnode } NewNode end end

166 83 a @beginspecial @setspecial
 tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def /ArrowInside
{ } def  0.4 SLW 0. setgray  /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  [ tx@NodeDict begin tx@NodeDict /N@Q known {
/N@Q load GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict
/N@P known { /N@P load GetCenter } { 0 0 } ifelse end  /Lineto /lineto
load def false NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length
0 gt { 2 copy /y1 ED /x1 ED ArrowA x1 y1 /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub atan def /ArrowPos 0.  def /Length x2 x1 sub y2 y1 sub Pyth def
/dArrowPos 0.5  abs def { /ArrowPos ArrowPos dArrowPos add def ArrowPos
Length gt { exit } if x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } loop }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if  gsave 0.4 SLW 0. setgray [  5.0  3.0
] 0 0 add  dup 0 gt { /a .5 def PathLength exch div } { pop /a 1 def
PathLength } ifelse /b ED dup /X ED 0 get /y ED /z 0 X {add} forall
def b a .5 sub 2 mul y mul sub z Div round z mul a .5 sub 2 mul y mul
add b exch Div /z ED false X { z mul } forall X astore {0 gt or} forall
{ X 1 a sub y mul } { [ 1 0 ] 0 } ifelse setdash stroke   grestore
end
 
@endspecial 166 83
a
 tx@Dict begin tx@NodeDict begin {tx@NodeDict begin tx@NodeDict /N@Q
known { /N@Q load GetCenter } { 0 0 } ifelse end /YA exch 15.00002
div def /XA exch 15.00002 div def tx@NodeDict begin tx@NodeDict /N@P'
known { /N@P' load GetCenter } { 0 0 } ifelse end /YB exch 15.00002
div def /XB exch 15.00002 div def /dx XB XA sub def /dy YB YA sub def
/dR dx dup mul dy dup mul add sqrt def /Length 2.99995 15.00002 div
def XA dx dR div Length mul add YA dy dR div Length mul add 15.00002
mul exch 15.00002 mul exch } false /N@@temp@a 10 {InitPnode } NewNode
end end
 166 83 a 166 83 a
 tx@Dict begin tx@NodeDict begin {tx@NodeDict begin tx@NodeDict /N@Q
known { /N@Q load GetCenter } { 0 0 } ifelse end /YA exch 15.00002
div def /XA exch 15.00002 div def tx@NodeDict begin tx@NodeDict /N@P
known { /N@P load GetCenter } { 0 0 } ifelse end /YB exch 15.00002
div def /XB exch 15.00002 div def /dx XB XA sub def /dy YB YA sub def
/dR dx dup mul dy dup mul add sqrt def /Length 2.99995 15.00002 div
def XA dx dR div Length mul add YA dy dR div Length mul add 15.00002
mul exch 15.00002 mul exch } false /N@@temp@b 10 {InitPnode } NewNode
end end
 166 83 a 166 83 a
 tx@Dict begin tx@NodeDict begin {tx@NodeDict begin tx@NodeDict /N@@temp@a
known { /N@@temp@a load GetCenter } { 0 0 } ifelse end /YA exch 15.00002
div def /XA exch 15.00002 div def tx@NodeDict begin tx@NodeDict /N@Q
known { /N@Q load GetCenter } { 0 0 } ifelse end /YB exch 15.00002
div def /XB exch 15.00002 div def XA 1 mul XB -1 mul add YA 1 mul YB
-1 mul add 15.00002 mul exch 15.00002 mul exch } false /N@@temp@Oa
10 {InitPnode } NewNode end end
 166 83 a 166 83
a
 tx@Dict begin tx@NodeDict begin {tx@NodeDict begin tx@NodeDict /N@@temp@b
known { /N@@temp@b load GetCenter } { 0 0 } ifelse end /YA exch 15.00002
div def /XA exch 15.00002 div def tx@NodeDict begin tx@NodeDict /N@Q
known { /N@Q load GetCenter } { 0 0 } ifelse end /YB exch 15.00002
div def /XB exch 15.00002 div def XA 1 mul XB -1 mul add YA 1 mul YB
-1 mul add 15.00002 mul exch 15.00002 mul exch } false /N@@temp@Ob
10 {InitPnode } NewNode end end
 166 83 a 166 83 a
 tx@Dict begin tx@NodeDict begin {tx@NodeDict begin tx@NodeDict /N@@temp@Oa
known { /N@@temp@Oa load GetCenter } { 0 0 } ifelse end /YA exch 15.00002
div def /XA exch 15.00002 div def tx@NodeDict begin tx@NodeDict /N@@temp@Ob
known { /N@@temp@Ob load GetCenter } { 0 0 } ifelse end /YB exch 15.00002
div def /XB exch 15.00002 div def XA 1 mul XB 1 mul add YA 1 mul YB
1 mul add 15.00002 mul exch 15.00002 mul exch } false /N@@temp@Oc 10
{InitPnode } NewNode end end
 166 83 a 166 83 a
 tx@Dict begin tx@NodeDict begin {tx@NodeDict begin tx@NodeDict /N@Q
known { /N@Q load GetCenter } { 0 0 } ifelse end /YA exch 15.00002
div def /XA exch 15.00002 div def tx@NodeDict begin tx@NodeDict /N@@temp@Oc
known { /N@@temp@Oc load GetCenter } { 0 0 } ifelse end /YB exch 15.00002
div def /XB exch 15.00002 div def XA 1 mul XB 1 mul add YA 1 mul YB
1 mul add 15.00002 mul exch 15.00002 mul exch } false /N@@temp@c 10
{InitPnode } NewNode end end
 166 83 a @beginspecial
@setspecial
 tx@Dict begin STP newpath 0.4 SLW 0. setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  0.4 SLW 0. setgray  /ArrowA {
moveto } def /ArrowB { } def /ArrowInside { } def  [ tx@NodeDict begin
tx@NodeDict /N@@temp@b known { /N@@temp@b load GetCenter } { 0 0 }
ifelse end tx@NodeDict begin tx@NodeDict /N@@temp@c known { /N@@temp@c
load GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@@temp@a
known { /N@@temp@a load GetCenter } { 0 0 } ifelse end  /Lineto /lineto
load def false NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length
0 gt { 2 copy /y1 ED /x1 ED ArrowA x1 y1 /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub atan def /ArrowPos 0.  def /Length x2 x1 sub y2 y1 sub Pyth def
/dArrowPos 0.5  abs def { /ArrowPos ArrowPos dArrowPos add def ArrowPos
Length gt { exit } if x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } loop }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if  gsave 0.4 SLW 0. setgray 0 setlinecap
stroke  grestore end
 
@endspecial @beginspecial @setspecial
 tx@Dict begin STP newpath end
 
@endspecial
166 83 a
 tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@Q known { /N@Q load
GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 166 83 a 166 83 a
 tx@Dict begin { 3.44444 7.90555 6.83331 1.94444 65.  Uput UUput }
PutCoor PutBegin  end
 166 83 a 133 103 a Fb(Q)166
83 y
 tx@Dict begin PutEnd  end
 166 83 a 166 83 a
 tx@Dict begin PutEnd  end
 166 83 a eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
